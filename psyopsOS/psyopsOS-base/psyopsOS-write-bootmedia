#!/usr/bin/env python3


import argparse
import json
import os
import re
import subprocess
import sys
from collections.abc import Callable
from typing import List


def broken_pipe_handler(func: Callable[[List[str]], int], *arguments: List[str]) -> int:
    """Handler for broken pipes

    Wrap the main() function in this to properly handle broken pipes
    without a giant nastsy backtrace.
    The EPIPE signal is sent if you run e.g. `script.py | head`.
    Wrapping the main function with this one exits cleanly if that happens.

    See <https://docs.python.org/3/library/signal.html#note-on-sigpipe>
    """
    try:
        returncode = func(*arguments)
        sys.stdout.flush()
    except BrokenPipeError:
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        # Convention is 128 + whatever the return code would otherwise be
        returncode = 128 + 1
        sys.exit(returncode)
    return returncode


def main(*arguments):
    parser = argparse.ArgumentParser("Update psyopsOS boot media")
    parser.add_argument(
        "--no-progress",
        help="By default, it shows progress, which requires coreutils dd. With this flag, BusyBox dd will work instead, but you will get no progress as the file is written.",
        action="store_true",
    )
    parser.add_argument(
        "isopath", help="The path to a new ISO image containing psyopsOS"
    )
    parsed = parser.parse_args(arguments[1:])

    lsblk_proc = subprocess.run(
        ["lsblk", "--output", "PATH,LABEL,MOUNTPOINT", "--json"],
        check=True,
        capture_output=True,
    )
    lsblk = json.loads(lsblk_proc.stdout)

    def label_is_psyopsos_boot(label: str) -> bool:
        """Return True if the label is a psyopsOS boot media label.

        Check for old and current labels.
        """
        boot_media_label_fragments = [
            "psyopsos-boot",  # Old 2023
            "psyboot",  # New 2023
        ]
        for fragment in boot_media_label_fragments:
            if fragment in label:
                return True
        return False

    bootmedia = None
    for device in lsblk["blockdevices"]:
        # Look for the iso9660 volume ID that is tagged with our label.
        # An example: 'partition-name: alpine-std psyopsos-boot x86_64'.
        # See the `alpinelabel` argument in tasks.py.
        if not label_is_psyopsos_boot(device.get("label", "")):
            continue

        # Make sure we find the main device, not a partition.
        # If the USB drive is /dev/sdq, then lsblk will see that both /dev/sdq and /dev/sdq1 have our volume ID.
        devpath = device.get("path", "") or ""
        if not devpath or not re.match(f"^/dev/[a-zA-Z]+$", devpath):
            continue

        bootmedia = device

    if not bootmedia:
        raise Exception(f"Could not find boot media, maybe it isn't mounted?")

    mtpt_modloop = subprocess.run(
        f"mountpoint /.modloop", shell=True, check=False, capture_output=True
    )
    if mtpt_modloop.returncode == 0:
        subprocess.run(f"umount /.modloop", shell=True, check=True)

    if bootmedia["mountpoint"]:
        subprocess.run(f"umount {bootmedia['mountpoint']}", shell=True, check=True)

    ddcmd = ["dd"]
    if not parsed.no_progress:
        ddcmd += ["status=progress"]
    ddcmd += [f"if={parsed.isopath}", f"of={bootmedia['path']}"]
    subprocess.run(ddcmd, check=True)


if __name__ == "__main__":
    broken_pipe_handler(main, *sys.argv)

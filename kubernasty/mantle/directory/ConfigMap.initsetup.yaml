apiVersion: v1
kind: ConfigMap
metadata:
  name: initsetup
  namespace: directory
data:

  envsubst.py: |
    #!/usr/bin/env python3
    # Poor pythonista's envsubst

    import os
    import sys

    for line in sys.stdin:
        sys.stdout.write(os.path.expandvars(line))

  setup.sh: |+
    #!/bin/sh
    set -eu

    # Put the LDAP password somewhere on the filesystem so that we can use it securely.
    umask 077
    mkdir -p /containeripc/topsecret
    # There must be no newline at the end of the password file.
    printf '%s' "$DS_DM_PASSWORD" >/containeripc/topsecret/ds-dm-password
    umask 022

    set -x

    chown -R 389:389 /containeripc
    chown -R 389:389 /data

  livenessProbe.sh: |+
    #!/bin/sh
    set -eu
    # When this succeeds, the server is up and running,
    # but it may not have finished applying all the configuration.
    ldapsearch -H ldap://localhost:3389 -x -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password -b "" -s base "objectclass=*"

  configure.sh: |+
    #!/bin/sh
    set -eu
    set -x

    echo "Starting configure.sh..."

    # Run configuration commands after the server is started.
    # These commands must be idempotent,
    # as a sidecar running this script will be started with the server.

    # Wait until the LDAP server is ready to accept connections.
    # (The stop test makes sure this script doesn't cause a container we want to stop
    # to hang until the stop timeout is reached.)
    while ! /initsetup/livenessProbe.sh; do
      echo "Waiting for LDAP server to start..."
      if test -f /containeripc/stop; then
        echo "Stopping because the main container is stopping"
        exit 1
      fi
      sleep 1
    done

    for configscript in /initsetup/initial_configure_*.sh; do
      bn=$(basename "$configscript")
      echo "Applying configuration script $bn..."
      /bin/sh "$configscript"
      echo "Finished applying configuration script $bn"
    done

    touch /containeripc/startupProbe
    # When all the configuration is applied, we're ready to accept traffic.

    # Every 30 seconds, check for other deployed replicas
    while true; do
      echo "$(date) Reconciling cluster replicas with LDAP replication agreements..."
      /initsetup/reconcile_replication.py || true
      sleep 30
    done

    # We have to stay running forever or else Kubernetes will think the container has crashed.

  initial_configure_10_backend.sh: |+
    #!/bin/sh
    set -eux

    case $(dsconf localhost backend get-tree) in
      *"$DS_SUFFIX_NAME"*)
        echo "Suffix $DS_SUFFIX_NAME already exists as a backend";;
      *)
        echo "Creating suffix $DS_SUFFIX_NAME as a backend"
        dsconf localhost backend create --suffix "$DS_SUFFIX_NAME" --be-name userroot --create-suffix --create-entries
        ;;
    esac

    function ldapmodify_local() {
      ldapmodify -H ldap://localhost:3389 -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password
    }

    python3 /initsetup/envsubst.py < /initsetup/users.ldif > /tmp/users-substituted.ldif

    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /initsetup/structure.ldif
    # ldapadd -D "cn=Directory Manager" -W -x -c -f /initsetup/groups.ldif
    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /tmp/users-substituted.ldif

    ldapmodify_local -x -c -f /initsetup/structure.ldif
    ldapmodify_local -x -c -f /initsetup/groups.ldif
    ldapmodify_local -x -c -f /tmp/users-substituted.ldif

  initial_configure_20_replication.sh: |+
    #!/bin/sh
    set -eu

    # We create a replica ID, which must be an integer between 1 and 65534.
    # This service is deployed as a StatefulSet with ecah pod named e.g. dirsrv-0, dirsrv-1, etc,
    # so we can use the ordinal index of the pod as the basis for the replica ID.
    statefulset_index=$(echo "$HOSTNAME" | sed 's/.*-//')
    # StatefulSet indices are 0-based, but replica IDs are 1-based.
    replica_id=$((statefulset_index + 1))

    case "$(dsconf localhost replication list)" in
      *"$DS_SUFFIX_NAME"*)
        echo "Suffix $DS_SUFFIX_NAME already has replication enabled";;
      *)
        echo "Enabling replication for suffix $DS_SUFFIX_NAME"
        dsconf localhost replication enable --suffix "$DS_SUFFIX_NAME" --role=supplier --replica-id "$replica_id"
        ;;
    esac

    # This appears to be idempotent
    dsconf localhost replication create-manager --name rmanager --passwd "$DS_RMANAGER_PASSWORD" --suffix "$DS_SUFFIX_NAME"

  reconcile_replication.py: |+
    #!/usr/bin/env python3

    import logging
    import os
    import socket
    import subprocess

    logging.basicConfig(
      level=logging.DEBUG, format="[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s"
    )
    LOGGER = logging.getLogger(__name__)

    def getreplicas():
      """Get a list of all the other replicas in the cluster from cluster DNS.

      This relies on a **headless** service called dirsrv in this namespace.
      A headless service is a service with ClusterIP: None,
      which is implemented as a round-robin DNS record.
      Return a list of FQDNs of all the replicas.
      """
      _, _, ips = socket.gethostbyname_ex('dirsrv')
      k8s_replicas = [socket.gethostbyaddr(ip)[0] for ip in ips]
      LOGGER.debug(f"Found StatefulSet replicas: {k8s_replicas}")
      return k8s_replicas

    def getagreements(ds_suffix_name):
      """Get a list of replication agreements from the LDAP server

      dsconf returns a list of agreements in LDIF format.
      The cn: lines are the agreement names; when we create them below,
      we use the hostnames.
      This function returns just the agreement names (DNS FQDNs) separated by newlines.
      """

      agreements_result = subprocess.run(['dsconf', '-D', 'cn=Directory Manager', 'localhost', 'repl-agmt', 'list', '--suffix', ds_suffix_name], check=True, text=True, capture_output=True)
      agreement_fqdns = [line[4:] for line in agreements_result.stdout.splitlines() if line.startswith('cn: ')]
      LOGGER.debug(f"Found LDAP agreements: {agreement_fqdns}")
      return agreement_fqdns

    def reconcile_deployed_instances(hostname, ds_suffix_name, ds_rmanager_password):
      """Reconcile the list of running replicas in the StatefulSet with the list of replication agreements in the LDAP server.

      TODO: Make this more robust.
      <https://access.redhat.com/documentation/en-us/red_hat_directory_server/12/html/configuring_and_managing_replication/assembly_removing-an-instance-from-a-replication-topology_configuring-and-managing-replication#proc_removing-a-supplier-from-a-replication-topology_assembly_removing-an-instance-from-a-replication-topology>
      """

      # The dsconf command takes a few seconds, so we just run it once
      origagreements = getagreements(ds_suffix_name)

      # Make sure we have a replication agreement with every other pod.
      new_replicas = []
      for replica_fqdn in getreplicas():
        replica_hostname = replica_fqdn.split('.')[0]
        if replica_hostname == hostname:
          # Don't try to replicate to ourselves
          continue
        if replica_fqdn in origagreements:
          LOGGER.debug(f"Already replicating to {replica_fqdn}")
          continue
        new_replicas.append(replica_fqdn)

      LOGGER.debug(f"Found {len(new_replicas)} new replicas: {new_replicas}")
      for replica_fqdn in new_replicas:
        LOGGER.debug(f"Setting up replication agreement with {replica_fqdn}")
        subprocess.run(['dsconf', 'localhost', 'repl-agmt', 'create',
                        '--suffix', ds_suffix_name,
                        '--bind-dn', 'cn=rmanager,cn=config',
                        '--bind-passwd', ds_rmanager_password,
                        '--bind-method', 'SIMPLE',
                        '--conn-protocol', 'LDAP',
                        '--host', replica_fqdn,
                        '--port', '3389',
                        replica_fqdn])

      # Make sure we don't have any replication agreements with pods that no longer exist.
      stale_agreements = set(origagreements) - set(getreplicas())
      LOGGER.debug(f"Found {len(stale_agreements)} stale agreements: {stale_agreements}")
      for agreement in stale_agreements:
        # All LDAP servers with an active replication agreement to the stale server must remove their agreement.
        LOGGER.debug(f"Removing replication agreement with {agreement}")
        subprocess.run(['dsconf', 'localhost', 'repl-agmt', 'delete', '--suffix', ds_suffix_name, agreement])
        # Only *one* LDAP server should rmove the RUVs of the stale server.
        # We have the first server in the StatefulSet handle this for us.
        # TODO: What could possibly go wrong
        # Search for RUVs for all other servers (even removed replicas) with something like:
        # ldapsearch -H ldap://localhost:3389 -x -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password -LLL -b cn=config "(objectClass=nsds5ReplicationAgreement)" nsds50ruv
        if socket.gethostname().endswith('-0'):
          remove_ruv(agreement)
          LOGGER.debug(f"Remove RUVs for {agreement}")
          subprocess.run(['dsconf', 'localhost', 'repl-tasks', 'cleanallruv', '--suffix', ds_suffix_name, "--replica-id", replica_id])
        else:
          LOGGER.debug(f"Skipping RUV removal for {agreement}")

    if __name__ == '__main__':
      reconcile_deployed_instances(os.environ['HOSTNAME'], os.environ['DS_SUFFIX_NAME'], os.environ['DS_RMANAGER_PASSWORD'])

  configure_replication.sh: |+
    #!/bin/sh
    set -eu

    # This script would work fine on busybox, but the dirsrv image doesn't have fucking nslookup.

    # Do a DNS reverse lookup; find the hostname for each IP address.
    rlookup() {
      nslookup "$1" | tail +3 | grep 'name =' | sed 's/.*name = //'
    }

    # Use DNS to find all the other replicas idempotently.
    # This relies on a **headless** service called dirsrv in this namespace.
    # A headless service is a service with ClusterIP: None,
    # which is implemented as a round-robin DNS record.
    # Return a list of FQDNs of all the replicas.
    getreplicas() {
      nslookup dirsrv | tail +3 | grep Address: | sed 's/Address: //'
    }

    # Return a list of replication agreements.
    # dsconf returns a list of agreements in LDIF format.
    # The cn: lines are the agreement names; when we create them below,
    # we use the hostnames.
    # This function returns just the agreement names (DNS FQDNs) separated by newlines.
    getagreements() {
      dsconf -D "cn=Directory Manager" localhost repl-agmt list --suffix "$DS_SUFFIX_NAME" | grep '^cn: ' | sed 's/cn: //'
    }

    # The dsconf command takes a few seconds, so we just run it once
    origagreements=$(getagreements)

    # Make sure we have a replication agreement with every other pod.
    for addr in $(getreplicas); do
      addr_dnsname=$(rlookup "$addr")
      if test -z "$addr_dnsname"; then
        echo "No DNS name found for address $addr"
        exit 1
      fi
      addr_hostname=${addr_dnsname%.}
      if test "$addr_hostname" = "$HOSTNAME"; then
        # Don't try to replicate to ourselves
        continue
      fi

      replicationg=
      for agreement in $origagreements; do
        if test "$agreement" = "$addr_hostname"; then
          echo "Already replicating to $addr_hostname"
          replicating=true
          break
        fi
      done
      test "$replicating" && continue

      echo "Setting up replication agreement with $addr_hostname"
      dsconf localhost repl-agmt create \
        --suffix "$DS_SUFFIX_NAME" \
        --bind-dn cn=rmanager,cn=config \
        --bind-passwd "$DS_RMANAGER_PASSWORD" \
        --bind-method SIMPLE \
        --conn-protocol LDAP \
        --host "$addr_dnsname" \
        --port 3389 \
        "$addr_dnsname"
    done

    # Make sure we don't have any replication agreements with pods that no longer exist.
    for agreement in $origagreements; do
      exists=
      for addr in $(getreplicas); do
        addr_dnsname=$(rlookup "$addr")
        if test "$agreement" = "$addr_dnsname"; then
          # The pod exists
          exist=true
          break
        fi
      done
      if test -z "$exists"; then
        echo "Removing replication agreement with $agreement"
        dsconf localhost repl-agmt delete --suffix "$DS_SUFFIX_NAME" "$agreement"
      fi
    done


  # WARNING: be careful with LDIF files, a newline separates entries (like YAML ---)

  structure.ldif: |+
    #### The base entry and access control instructions
    dn: dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: domain
    -
    add: dc
    dc: micahrl
    -
    # Users can modify their own entries
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Self Write"; allow(write) userdn = "ldap:///self";)
    -
    # Directory Administrators can modify any entry
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Directory Admin Group"; allow(write) groupdn = "ldap:///cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me";)
    -
    # Anonymous users can read the directory
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Anonymous Access"; allow(read, search, compare) userdn = "ldap:///anyone";)

    #### The People OU
    dn: ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: People

    #### The Groups OU
    dn: ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: Groups

  groups.ldif: |+
    #### The Directory Administrators group
    dn: cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Directory Administrators
    -
    add: uniqueMember
    uniqueMember: uid=mrladmin,dc=micahrl,dc=me

    #### The Service Accounts group
    dn: cn=Service Accounts,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Service Accounts

  # Most users, even my regular user, is not defined here,
  # because users defined here shouldn't change their passwords.
  # (I don't want to have to update this file every time I change my password,
  # and what happens when we add replication?)
  # Note that passwords are set here as environment variables
  # and filled in from variables set in the dirsrv-env Secret.
  users.ldif: |+
    #### The mrladmin user
    dn: uid=mrladmin,ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: person
    -
    add: objectClass
    objectClass: organizationalPerson
    -
    add: objectClass
    objectClass: inetOrgPerson
    -
    add: objectClass
    objectClass: inetUser
    -
    add: objectClass
    objectClass: posixAccount
    -
    add: cn
    cn: Micah R Ledbetter (admin)
    -
    add: uid
    uid: mrladmin
    -
    add: description
    description: Hot, smart, and (most importantly) good at LDAP
    -
    add: userPassword
    userPassword: ${DS_MRLADMIN_PASSWORD}
    -
    add: ou
    ou: People
    -
    add: mail
    mail: me+ldapadmin@micahrl.com
    -
    add: uidNumber
    uidNumber: 10666
    -
    add: gidNumber
    gidNumber: 10666
    -
    add: homeDirectory
    homeDirectory: /home/mrladmin
    -
    add: title
    title: Overanalyst

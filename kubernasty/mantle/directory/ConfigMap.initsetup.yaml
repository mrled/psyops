apiVersion: v1
kind: ConfigMap
metadata:
  name: initsetup
  namespace: directory
data:

  envsubst.py: |
    #!/usr/bin/env python3
    # Poor pythonista's envsubst

    import os
    import sys

    for line in sys.stdin:
        sys.stdout.write(os.path.expandvars(line))

  setup.sh: |+
    #!/bin/sh
    set -eu

    # Put the LDAP password somewhere on the filesystem so that we can use it securely.
    umask 077
    mkdir -p /containeripc/topsecret
    # There must be no newline at the end of the password file.
    printf '%s' "$DS_DM_PASSWORD" >/containeripc/topsecret/ds-dm-password
    umask 022

    set -x

    chown -R 389:389 /containeripc
    chown -R 389:389 /data

  livenessProbe.sh: |+
    #!/bin/sh
    set -eu
    # When this succeeds, the server is up and running,
    # but it may not have finished applying all the configuration.
    ldapsearch -H ldap://localhost:3389 -x -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password -b "" -s base "objectclass=*"

  configure.sh: |+
    #!/bin/sh
    set -eu
    set -x

    echo "Starting configure.sh..."

    # Run configuration commands after the server is started.
    # These commands must be idempotent,
    # as a sidecar running this script will be started with the server.

    # Wait until the LDAP server is ready to accept connections.
    # (The stop test makes sure this script doesn't cause a container we want to stop
    # to hang until the stop timeout is reached.)
    while ! /initsetup/livenessProbe.sh; do
      echo "Waiting for LDAP server to start..."
      if test -f /containeripc/stop; then
        echo "Stopping because the main container is stopping"
        exit 1
      fi
      sleep 1
    done

    for configscript in /initsetup/configure_*.sh; do
      bn=$(basename "$configscript")
      echo "Applying configuration script $bn..."
      /bin/sh "$configscript"
      echo "Finished applying configuration script $bn"
    done

    touch /containeripc/startupProbe
    # When all the configuration is applied, we're ready to accept traffic.

    # We have to stay running forever or else Kubernetes will think the container has crashed.
    tail -f /dev/null

  configure_10_backend.sh: |+
    #!/bin/sh
    set -eu

    dsconf localhost backend create --suffix "$DS_SUFFIX_NAME" --be-name userroot --create-suffix --create-entries

    function ldapmodify_local() {
      ldapmodify -H ldap://localhost:3389 -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password
    }

    python3 /initsetup/envsubst.py < /initsetup/users.ldif > /tmp/users-substituted.ldif

    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /initsetup/structure.ldif
    # ldapadd -D "cn=Directory Manager" -W -x -c -f /initsetup/groups.ldif
    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /tmp/users-substituted.ldif

    ldapmodify_local -x -c -f /initsetup/structure.ldif
    ldapmodify_local -x -c -f /initsetup/groups.ldif
    ldapmodify_local -x -c -f /tmp/users-substituted.ldif

  # WARNING: be careful with LDIF files, a newline separates entries (like YAML ---)

  structure.ldif: |+
    #### The base entry and access control instructions
    dn: dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: domain
    -
    add: dc
    dc: micahrl
    -
    # Users can modify their own entries
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Self Write"; allow(write) userdn = "ldap:///self";)
    -
    # Directory Administrators can modify any entry
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Directory Admin Group"; allow(write) groupdn = "ldap:///cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me";)
    -
    # Anonymous users can read the directory
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Anonymous Access"; allow(read, search, compare) userdn = "ldap:///anyone";)

    #### The People OU
    dn: ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: People

    #### The Groups OU
    dn: ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: Groups

  groups.ldif: |+
    #### The Directory Administrators group
    dn: cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Directory Administrators
    -
    add: uniqueMember
    uniqueMember: uid=mrladmin,dc=micahrl,dc=me

    #### The Service Accounts group
    dn: cn=Service Accounts,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Service Accounts

  # Most users, even my regular user, is not defined here,
  # because users defined here shouldn't change their passwords.
  # (I don't want to have to update this file every time I change my password,
  # and what happens when we add replication?)
  # Note that passwords are set here as environment variables
  # and filled in from variables set in the dirsrv-static-users Secret.
  users.ldif: |+
    #### The mrladmin user
    dn: uid=mrladmin,ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: person
    -
    add: objectClass
    objectClass: organizationalPerson
    -
    add: objectClass
    objectClass: inetOrgPerson
    -
    add: objectClass
    objectClass: inetUser
    -
    add: objectClass
    objectClass: posixAccount
    -
    add: cn
    cn: Micah R Ledbetter (admin)
    -
    add: uid
    uid: mrladmin
    -
    add: description
    description: Hot, smart, and (most importantly) good at LDAP
    -
    add: userPassword
    userPassword: ${mrladmin_password}
    -
    add: ou
    ou: People
    -
    add: mail
    mail: me+ldapadmin@micahrl.com
    -
    add: uidNumber
    uidNumber: 10666
    -
    add: gidNumber
    gidNumber: 10666
    -
    add: homeDirectory
    homeDirectory: /home/mrladmin
    -
    add: title
    title: Overanalyst

  configure_20_replication.sh: |+
    #!/bin/sh
    set -eu

    # We create a replica ID, which must be an integer between 1 and 65534.
    # This service is deployed as a StatefulSet with ecah pod named e.g. dirsrv-0, dirsrv-1, etc,
    # so we can use the ordinal index of the pod as the replica ID.
    statefulset_index=$(echo "$HOSTNAME" | sed 's/.*-//')
    # StatefulSet indices are 0-based, but replica IDs are 1-based.
    replica_id=$((statefulset_index + 1))

    dsconf localhost replication enable --suffix "$DS_SUFFIX_NAME" --role=supplier --replica-id "$replica_id"


  sidecar_webhook_set_replication_agreements: |+
    #!/bin/sh
    set -eu

    # Use DNS to find all the other replicas idempotently.
    # This relies on a **headless** service called dirsrv in this namespace.
    # A headless service is a service with ClusterIP: None,
    # which is implemented as a round-robin DNS record.

    agreements=$(dsconf -D "cn=Directory Manager" localhost repl-agmt list --suffix "$DS_SUFFIX_NAME")

    for addr in $(nslookup whoami | tail +3 | grep Address: | sed 's/Address: //'); do
      dnsname=$(nslookup "$addr" | tail +3 | grep 'name =' | sed 's/.*name = //')
      if test -z "$dnsname"; then
        echo "No DNS name found for address $addr"
        exit 1
      fi
    done


  sidecar_webhook_receiver.py: |+
    #!/usr/bin/env python3

    import http.server
    import subprocess
    import time
    from threading import Lock, Timer

    class Handler(http.server.BaseHTTPRequestHandler):
        last_request_time = {}
        request_queue = {}
        lock = Lock()

        routes = {
            '/scan': '/path/to/your/script.sh',
        }

        def process_request(self, path):
            with self.lock:
                if self.request_queue[path]:
                    # Process the last request in the queue
                    subprocess.run(self.routes[path])
                    self.request_queue[path] = []
                    self.last_request_time[path] = time.time()

        def do_POST(self):
            if self.path in self.routes:
                current_time = time.time()
                with self.lock:
                    if self.path not in self.last_request_time:
                        self.last_request_time[self.path] = 0
                        self.request_queue[self.path] = []

                    if current_time - self.last_request_time[self.path] >= 1:
                        # Process the request immediately
                        self.last_request_time[self.path] = current_time
                        subprocess.run(self.routes[path])
                        self.send_response(200)
                        self.end_headers()
                        self.wfile.write(b'Script executed')
                    else:
                        # Queue the request
                        self.request_queue[self.path].append(self)
                        if len(self.request_queue[self.path]) == 1:
                            # Schedule to process the last request in the queue after 1 second
                            Timer(1 - (current_time - self.last_request_time[self.path]), self.process_request, [self.path]).start()
                        self.send_response(200)
                        self.end_headers()
                        self.wfile.write(b'Request queued')
            else:
                self.send_response(404)
                self.end_headers()
                self.wfile.write(b'Path not found')

    httpd = http.server.HTTPServer(('0.0.0.0', 8080), Handler)
    httpd.serve_forever()

  setup_replication.sh: |
    #!/bin/sh

    ldapmodify -x -H ldap://ldap-0.ldap-service -D "cn=Directory Manager" -w password <<EOF
    dn: cn=replica,cn="dc=example,dc=com",cn=mapping tree,cn=config
    objectClass: top
    objectClass: nsds5replica
    nsDS5ReplicaRoot: dc=example,dc=com
    nsDS5ReplicaId: 1
    nsDS5ReplicaType: 3
    nsds5Flags: 1
    nsds5ReplicaBindDN: cn=Replication Manager,cn=config
    nsds5ReplicaTransportInfo: LDAP
    nsds5ReplicaUpdateSchedule: 0000-2359 0123456
    nsds5ReplicaReferral: ldap://ldap-1.ldap-service:389
    nsds5ReplicaBindMethod: SIMPLE
    nsds5ReplicaCredentials: replication_password
    EOF

    ldapmodify -x -H ldap://ldap-1.ldap-service -D "cn=Directory Manager" -w password <<EOF
    dn: cn=replica,cn="dc=example,dc=com",cn=mapping tree,cn=config
    objectClass: top
    objectClass: nsds5replica
    nsDS5ReplicaRoot: dc=example,dc=com
    nsDS5ReplicaId: 2
    nsDS5ReplicaType: 3
    nsds5Flags: 1
    nsds5ReplicaBindDN: cn=Replication Manager,cn=config
    nsds5ReplicaTransportInfo: LDAP
    nsds5ReplicaUpdateSchedule: 0000-2359 0123456
    nsds5ReplicaReferral: ldap://ldap-0.ldap-service:389
    nsds5ReplicaBindMethod: SIMPLE
    nsds5ReplicaCredentials: replication_password
    EOF

    ldapmodify -x -H ldap://ldap-0.ldap-service -D "cn=Directory Manager" -w password <<EOF
    dn: cn=agreement,cn=replica,cn="dc=example,dc=com",cn=mapping tree,cn=config
    objectClass: top
    objectClass: nsds5ReplicationAgreement
    cn: agreement
    nsDS5ReplicaHost: ldap-1.ldap-service
    nsDS5ReplicaPort: 389
    nsDS5ReplicaBindDN: cn=Replication Manager,cn=config
    nsDS5ReplicaCredentials: replication_password
    nsDS5ReplicaRoot: dc=example,dc=com
    nsDS5ReplicaTransportInfo: LDAP
    EOF

    ldapmodify -x -H ldap://ldap-1.ldap-service -D "cn=Directory Manager" -w password <<EOF
    dn: cn=agreement,cn=replica,cn="dc=example,dc=com",cn=mapping tree,cn=config
    objectClass: top
    objectClass: nsds5ReplicationAgreement
    cn: agreement
    nsDS5ReplicaHost: ldap-0.ldap-service
    nsDS5ReplicaPort: 389
    nsDS5ReplicaBindDN: cn=Replication Manager,cn=config
    nsDS5ReplicaCredentials: replication_password
    nsDS5ReplicaRoot: dc=example,dc=com
    nsDS5ReplicaTransportInfo: LDAP
    EOF

    echo "Replication setup completed"
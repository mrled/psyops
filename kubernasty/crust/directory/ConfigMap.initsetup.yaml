apiVersion: v1
kind: ConfigMap
metadata:
  name: initsetup
  namespace: directory
data:

  envsubst.py: |
    #!/usr/bin/env python3
    # Poor pythonista's envsubst

    import os
    import sys

    for line in sys.stdin:
        sys.stdout.write(os.path.expandvars(line))

  setup.sh: |+
    #!/bin/sh
    set -eu

    # Put the LDAP password somewhere on the filesystem so that we can use it securely.
    umask 077
    mkdir -p /containeripc/topsecret
    # There must be no newline at the end of the password file.
    printf '%s' "$DS_DM_PASSWORD" >/containeripc/topsecret/ds-dm-password
    umask 022

    set -x

    chown -R 389:389 /containeripc
    chown -R 389:389 /data

  livenessProbe.sh: |+
    #!/bin/sh
    set -eu
    # When this succeeds, the server is up and running,
    # but it may not have finished applying all the configuration.
    ldapsearch -H ldap://localhost:3389 -x -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password -b "" -s base "objectclass=*"

  configure.sh: |+
    #!/bin/sh
    set -eu
    set -x

    echo "Starting configure.sh..."

    # Run configuration commands after the server is started.
    # These commands must be idempotent,
    # as a sidecar running this script will be started with the server.

    # Wait until the LDAP server is ready to accept connections.
    # (The stop test makes sure this script doesn't cause a container we want to stop
    # to hang until the stop timeout is reached.)
    while ! /initsetup/livenessProbe.sh; do
      echo "Waiting for LDAP server to start..."
      if test -f /containeripc/stop; then
        echo "Stopping because the main container is stopping"
        exit 1
      fi
      sleep 1
    done

    for configscript in /initsetup/initial_configure_*.sh; do
      bn=$(basename "$configscript")
      echo "Applying configuration script $bn..."
      /bin/sh "$configscript"
      echo "Finished applying configuration script $bn"
    done

    echo "We have applied all configuration scripts and are ready to accept traffic."
    touch /containeripc/startupProbe

    echo "We're done, but we have to stay running forever or else Kubernetes will think the pod needs to be restarted."
    while true; do sleep 86400; done

  initial_configure_10_backend.sh: |+
    #!/bin/sh
    set -eux

    case $(dsconf localhost backend get-tree) in
      *"$DS_SUFFIX_NAME"*)
        echo "Suffix $DS_SUFFIX_NAME already exists as a backend";;
      *)
        echo "Creating suffix $DS_SUFFIX_NAME as a backend"
        dsconf localhost backend create --suffix "$DS_SUFFIX_NAME" --be-name userroot --create-suffix --create-entries
        ;;
    esac

    function ldapmodify_local() {
      ldapmodify -H ldap://localhost:3389 -D "cn=Directory Manager" -y /containeripc/topsecret/ds-dm-password
    }

    python3 /initsetup/envsubst.py < /initsetup/users.ldif > /tmp/users-substituted.ldif

    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /initsetup/structure.ldif
    # ldapadd -D "cn=Directory Manager" -W -x -c -f /initsetup/groups.ldif
    # ldapadd -D "cn=Directory Manager" -W -H ldap://localhost -x -c -f /tmp/users-substituted.ldif

    ldapmodify_local -x -c -f /initsetup/structure.ldif
    ldapmodify_local -x -c -f /initsetup/groups.ldif
    ldapmodify_local -x -c -f /tmp/users-substituted.ldif

  initial_configure_20_replication.sh: |+
    #!/bin/sh
    set -eu

    # We create a replica ID, which must be an integer between 1 and 65534.
    # This service is deployed as a StatefulSet with ecah pod named e.g. dirsrv-0, dirsrv-1, etc,
    # so we can use the ordinal index of the pod as the basis for the replica ID.
    statefulset_index=$(echo "$HOSTNAME" | sed 's/.*-//')
    # StatefulSet indices are 0-based, but replica IDs are 1-based.
    replica_id=$((statefulset_index + 1))

    case "$(dsconf localhost replication list)" in
      *"$DS_SUFFIX_NAME"*)
        echo "Suffix $DS_SUFFIX_NAME already has replication enabled";;
      *)
        echo "Enabling replication for suffix $DS_SUFFIX_NAME"
        dsconf localhost replication enable --suffix "$DS_SUFFIX_NAME" --role=supplier --replica-id "$replica_id"
        ;;
    esac

    # This appears to be idempotent
    dsconf localhost replication create-manager --name rmanager --passwd "$DS_RMANAGER_PASSWORD" --suffix "$DS_SUFFIX_NAME"


  # WARNING: be careful with LDIF files, a newline separates entries (like YAML ---)

  structure.ldif: |+
    #### The base entry and access control instructions
    dn: dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: domain
    -
    add: dc
    dc: micahrl
    -
    # Users can modify their own entries
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Self Write"; allow(write) userdn = "ldap:///self";)
    -
    # Directory Administrators can modify any entry
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Directory Admin Group"; allow(write) groupdn = "ldap:///cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me";)
    -
    # Anonymous users can read the directory
    add: aci
    aci: (target=ldap:///dc=micahrl,dc=me)(targetattr=*)(version 3.0; acl "Anonymous Access"; allow(read, search, compare) userdn = "ldap:///anyone";)

    #### The People OU
    dn: ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: People

    #### The Groups OU
    dn: ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: organizationalUnit
    -
    add: ou
    ou: Groups

  groups.ldif: |+
    #### The Directory Administrators group
    dn: cn=Directory Administrators,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Directory Administrators
    -
    add: uniqueMember
    uniqueMember: uid=mrladmin,dc=micahrl,dc=me

    #### The Service Accounts group
    dn: cn=Service Accounts,ou=Groups,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: groupOfUniqueNames
    -
    add: objectClass
    objectClass: groupOfNames
    -
    add: objectClass
    objectClass: inetAdmin
    -
    add: cn
    cn: Service Accounts

  # Most users, even my regular user, is not defined here,
  # because users defined here shouldn't change their passwords.
  # (I don't want to have to update this file every time I change my password,
  # and what happens when we add replication?)
  # Note that passwords are set here as environment variables
  # and filled in from variables set in the dirsrv-env Secret.
  users.ldif: |+
    #### The mrladmin user
    dn: uid=mrladmin,ou=People,dc=micahrl,dc=me
    changetype: modify
    add: objectClass
    objectClass: top
    -
    add: objectClass
    objectClass: person
    -
    add: objectClass
    objectClass: organizationalPerson
    -
    add: objectClass
    objectClass: inetOrgPerson
    -
    add: objectClass
    objectClass: inetUser
    -
    add: objectClass
    objectClass: posixAccount
    -
    add: cn
    cn: Micah R Ledbetter (admin)
    -
    add: uid
    uid: mrladmin
    -
    add: description
    description: Hot, smart, and (most importantly) good at LDAP
    -
    add: userPassword
    userPassword: ${DS_MRLADMIN_PASSWORD}
    -
    add: ou
    ou: People
    -
    add: mail
    mail: me+ldapadmin@micahrl.com
    -
    add: uidNumber
    uidNumber: 10666
    -
    add: gidNumber
    gidNumber: 10666
    -
    add: homeDirectory
    homeDirectory: /home/mrladmin
    -
    add: title
    title: Overanalyst

#!/bin/sh

importkey="$HOME/.psyops.secret.key.asc"
keyid=12E8CEC69AD7651DF8A97766EDD94B830D6F7ED9

gpgpassfile="$HOME/.gpg.passphrase"

testgpgpass() {
    # If the agent is running and the key was successfully decrypted, the --passphrase-file argument will be ignored
    killall gpg-agent 2>/dev/null
    if echo "MESSAGE" | gpg --batch --pinentry-mode loopback --sign --passphrase-file "$gpgpassfile" >/dev/null; then
        return 0
    fi
    return 1
}

testkeyimported() {
    if gpg --list-secret-keys | grep -q "$keyid"; then
        return 0
    fi
    return 1
}

gpgsavepassfile() {
    stty -echo
    printf "Enter passphrase for psyops key (id $keyid): "
    read -r passphrase
    stty echo
    echo ""
    printf "$passphrase" > "$gpgpassfile"
    passphrase=""
}

gpggetpass() {
    cat "$gpgpassfile"
}

gpgimportkey() {
    # It asks for the a passphrase on import, but it doesn't actually appear to use it? It will import a key with a bad passphrase...?
    passphrase="DUMMY"
    echo "$passphrase" | PASSPHRASE="$passphrase" gpg --batch --pinentry-mode loopback --command-fd 0 --status-fd 2 --import "$importkey"
}

# Will do nothing if the key already exists
gpgimportkey

# Don't loop forever in `while` or whatever, because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
if ! testgpgpass; then
    rm "$gpgpassfile" 2>/dev/null || true
    gpgsavepassfile
fi
if ! testegpgpass; then
    echo "Could not decrypt GPG key based on the entered passphrase, continuing without decrypting secrets" 1>&2
fi

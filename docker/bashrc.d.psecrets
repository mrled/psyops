#!/bin/sh

# Encrypted private GPG key path to import
importseckey="$HOME/.psyops.secret.gpg.key.asc"
# Unencrypted public GPG key path to import
importpubkey="$HOME/.psyops.secret.gpg.pubkey.asc"
# Unencrypted GPG ownertrust database to import
importtrust="$HOME/.psyops.secret.gpg.ownertrust.db.asc"
# Secret GPG key ID
seckeyid="3426CF80"
# Public GPG key ID
pubkeyid="664C82AD"
# Location to store (plaintext!) GPG passphrase
gpgpassfile="$HOME/.gpg.passphrase"
# Location to decrypt secrets repo
repopath="$HOME/.secrets"
# Unencrypted public SSH key path
pubsshkey="$HOME/.ssh/id_ed25519.pub"
# Encrypted private SSH key path
encsshkey="$HOME/.ssh/id_ed25519.gpg"
# Location to decrypt private SSH key
decsshkey="$HOME/.ssh/id_ed25519"
# Branch name for encrypted commits. Must be name of both the local branch we'll check out AND the remote branch that is encrypted before pushing
branchname="master"
# Name to use for the gcrypt remote
remotename="origin"
# URI for the gcrypt remote
remoteuri="gcrypt::git@github.com:mrled/psyops-secrets.git"

testgpgpass() {
    if echo "MESSAGE" | gpg --no-use-agent --batch --sign --passphrase-file "$gpgpassfile" >/dev/null 2>&1; then
        return 0
    fi
    return 1
}

testkeyimported() {
    if gpg --list-secret-keys | grep -q "$seckeyid"; then
        return 0
    fi
    return 1
}

gpgsavepassfile() {
    stty -echo
    printf "Enter passphrase for psyops key (id $seckeyid): "
    read -r passphrase
    stty echo
    echo ""
    printf "$passphrase" > "$gpgpassfile"
    passphrase=""
}

gpgimportkeys() {
    # It asks for the a passphrase on import, but it doesn't actually appear to use it? It will import a key with a bad passphrase...?
    gpg --batch --import "$importseckey"
    gpg --batch --import "$importpubkey"
    gpg --batch --import-ownertrust "$importtrust"
}

decryptsshkey() {
    gpg --batch --decrypt --passphrase-file "$gpgpassfile" --output "$decsshkey" "$encsshkey"
    chmod 0600 "$decsshkey"
    # Regenerate the public key from the private key:
    ssh-keygen -y -f "$decsshkey" > "$pubsshkey"
}

# Assume that $repopath represents a cloned gcrypt repo, but gcrypt hasn't been configured
# Configure gcrypt in that repo
# If it looks like gcrypt has already been configured, do nothing
secretssetup() {
    pushd "$repopath" >/dev/null
    if ! test "$(git config --get gcrypt.gpg-args)"; then
        git config gcrypt.gpg-args "--batch --no-tty --passphrase-file $gpgpassfile"
        git remote remove "$remotename" || true
        git remote add "$remotename" "$remoteuri"
        git fetch "$remotename"
        git checkout -b "${branchname}-tmp" "${remotename}/${branchname}"
        git branch -D "$branchname"
        git branch -m "${branchname}-tmp" "$branchname"
    fi
    popd >/dev/null
}

# Unlock when starting the container
unlocklogin() {
    # Will do nothing if the key already exists
    gpgimportkeys

    # Don't loop forever in `while` or whatever, because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
    success=
    ctr=1
    while test $ctr -le 3; do
        if testgpgpass; then
            success=1
            break
        fi
        rm "$gpgpassfile" 2>/dev/null || true
        echo "No passphrase (or an incorrect passphrase) was entered. Attempt $ctr."
        gpgsavepassfile
        ctr=$((ctr+1))
    done
    if ! test "$success"; then
        echo "Could not decrypt GPG key based on the entered passphrase, continuing without decrypting secrets" 1>&2
    else
        decryptsshkey
        secretssetup
    fi
}

unlocklogin

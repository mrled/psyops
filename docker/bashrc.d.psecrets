#!/bin/sh

importseckey="$HOME/.psyops.secret.gpg.key.asc"
importpubkey="$HOME/.psyops.secret.gpg.pubkey.asc"
importtrust="$HOME/.psyops.secret.gpg.ownertrust.db.asc"
keyid=3426CF80
gpgpassfile="$HOME/.gpg.passphrase"
repopath="$HOME/.secrets"

# Name of the local branch of decrypted files
lbranch="decrypted"
# Name of the remote branch that git-remote-gcrypt will push to and pull from
rbranch="encrypted"
# Name to use for the gcrypt remote
crname="gcrypt"
# URI for the gcrypt remote
cruri="gcrypt::git@github.com:mrled/psyops-secrets.git"
# Name to use for the initial checkout of the gcrypt remote (which cannot require an SSH key, since our SSH key is one of the things we're checking out)
pubcrname="gcrypthttps"
# URI for the public gcrypt remote
pubcruri="https://github.com/mrled/psyops-secrets"

testgpgpass() {
    if echo "MESSAGE" | gpg --no-use-agent --batch --sign --passphrase-file "$gpgpassfile" >/dev/null 2>&1; then
        return 0
    fi
    return 1
}

testkeyimported() {
    if gpg --list-secret-keys | grep -q "$keyid"; then
        return 0
    fi
    return 1
}

gpgsavepassfile() {
    stty -echo
    printf "Enter passphrase for psyops key (id $keyid): "
    read -r passphrase
    stty echo
    echo ""
    printf "$passphrase" > "$gpgpassfile"
    passphrase=""
}

gpgimportkeys() {
    # It asks for the a passphrase on import, but it doesn't actually appear to use it? It will import a key with a bad passphrase...?
    gpg --batch --import "$importseckey"
    gpg --batch --import "$importpubkey"
    gpg --batch --import-ownertrust "$importtrust"
}

secretssetup() {
    cd "$repopath"

    # Initially, we have not yet decrypted our SSH key, so we have to use a public HTTPS remote
    if ! test $(git remote | grep -q "^$pubcrname\$"); then
        git remote add "$pubcrname" "$pubcruri#$rbranch"
    fi
    git fetch "$pubcrname"

    # Tell git-remote-gcrypt how to decrypt the contents of the repository
    if ! $(git config --get gcrypt.gpg-args >/dev/null 2>&1); then
        git config gcrypt.gpg-args "--batch --no-tty --passphrase-file $gpgpassfile"
    fi

    # Check out and decrypt the contents of the remote branch, but don't create a local branch yet
    git checkout "$crname/$rbranch"

    # Now that we have a decrypted SSH key, we can get use the push-able SSH remote
    if ! test $(git remote | grep -q "^$crname\$"); then
        git remote add "$crname" "$cruri#$rbranch"
    fi
    git fetch "$crname"

    # Finally, check out and decrypt a local branch and attach it to the remote one
    git checkout -b "$lbranch" "$crname/$rbranch"
}

# Will do nothing if the key already exists
gpgimportkeys

# Don't loop forever in `while` or whatever, because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
success=
ctr=1
while test $ctr -le 3; do
    if testgpgpass; then
        success=1
        break
    fi
    rm "$gpgpassfile" 2>/dev/null || true
    echo "Wrong/no passphrase entered. Attempt $ctr."
    gpgsavepassfile
done
if ! test "$success"; then
    echo "Could not decrypt GPG key based on the entered passphrase, continuing without decrypting secrets" 1>&2
else
    secretssetup
fi
unset success ctr

#!/usr/bin/env python3

"""psecrets: manage PSYOPS secrets"""

import argparse
import getpass
import logging
import os
import shutil
import subprocess
import sys


scriptdir = os.path.dirname(os.path.realpath(__file__))  # pylint: disable=C0103
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)  # pylint: disable=C0103


# Helpers

class ResolvedPath(str):
    """Resolve a path

    Intended to be passed as a type= option to add_argument()
    (which is why it is a class and not a function)
    """
    def __new__(cls, path):
        return str.__new__(cls, os.path.realpath(os.path.normpath(os.path.expanduser(path))))


def homedir():
    """Find the homedir, crossplatformly"""
    for varname in ["HOME", "USERPROFILE"]:
        home = os.environ.get(varname)
        if home:
            logger.info(f"Found homedir '{home}' from {varname} environment variable")
        return home
    raise Exception(
        "Could not determine home directory - try setting a $HOME or %USERPROFILE% variable")


def idb_excepthook(type, value, tb):
    """Call an interactive debugger in post-mortem mode

    If you do "sys.excepthook = idb_excepthook", then an interactive debugger
    will be spawned at an unhandled exception
    """
    if hasattr(sys, 'ps1') or not sys.stderr.isatty():
        # we are in interactive mode or we don't have a tty-like
        # device, so we call the default hook
        sys.__excepthook__(type, value, tb)
    else:
        import pdb, traceback
        # we are NOT in interactive mode, print the exception...
        traceback.print_exception(type, value, tb)
        print
        # ...then start the debugger in post-mortem mode.
        pdb.pm()


def invoke(command, runner, env=None, cwd=None):
    """Stupid runner that logs for simple cases

    command: A commandline as a string array, like ['ls', '/tmp']
    runner: Something that takes a commandline, such as subprocess.check_call
    env: An optional environment to pass to the command
    cwd: An optional working directory to pass to the command
    """
    logger.info(
        f"Calling command {command} with environment {env} "
        f"from cwd {cwd} via runner {runner}")
    return runner(command, env=env, cwd=cwd)


# Implementation functions


def testgpgsign(keyid):
    """Test whether we can sign a message with a given GPG key
    """
    # Sign the /bin/sh binary; we don't care about the result, just a guaranteed path
    invoke(
        ['gpg', '--sign', '--output', '/dev/null', '--default-key', keyid, '/bin/sh'],
        subprocess.check_call)


def gpgimportkeys(secretkey, publickey, ownertrustdb):
    """ Import GPG keys

    - Will do nothing if the keys already exist
    - Does not require the passphrase to import, only to use after importing
    """
    logger.info(
        f"Attempting to import secret key {secretkey}, public key {publickey}, "
        f"and owner trust database {ownertrustdb}")
    invoke(['gpg', '--batch', '--import', secretkey], subprocess.call)
    invoke(['gpg', '--batch', '--import', publickey], subprocess.call)
    invoke(['gpg', '--batch', '--import-ownertrust', ownertrustdb], subprocess.call)


def decryptsshkey(encryptedkey, decryptedpath, pubkeypath):
    """ Decrypt an SSH key encrypted from a GPG private key

    (NOTE: This is NOT the same as an SSH private key encrypted with ssh-keygen)
    encryptedkey:   Path to encrypted SSH private key
    decryptedpath:  Path to save the decrypted SSH private key
    pubkeypath:     Path to save the public key, which we generate from the private key after
                    decrypting
    """

    logger.info(f"Attempting to decrypt SSH key")

    invoke(
        ['gpg', '--decrypt', '--yes', '--output', decryptedpath, encryptedkey],
        subprocess.check_call)

    # Regenerate the public key from the private key:
    pubkey = invoke(
        ['ssh-keygen', '-y', '-f', decryptedpath], subprocess.check_output)
    with open(pubkeypath, 'w') as pkf:
        pkf.write(pubkey.decode())


def secretssetup(
        checkoutdir, remotename, remoteuri, branchname,
        postdecscr=None):
    """Clone secrets repository and decrypt it with git-remote-gcrypt

    checkoutdir: The local checkout path
    remotename:  Name of the git remote
    remoteuri:   Bare (without the 'gcrypt::' prefix) URI for the gcrypt remote
    branchname:  Name of the git branch; local and remote branch *must* use
                 same name
    postdecscr:  A relative path to a script to run after decrypting the repo
    """

    tmpbranch = f'{branchname}-tmp'
    tmpremotename = f'{remotename}-tmp'
    gcrypturi = f'gcrypt::{remoteuri}'

    logger.info(
        f"Attempting to setup secrets for checkout dir {checkoutdir} "
        f"for git remote name {remotename} and URI {remoteuri} "
        f"and branch name {branchname}. Afterwards, will run a script at: {postdecscr}.")

    gcryptgpgargs = f'--batch'

    if os.path.exists(checkoutdir):
        shutil.rmtree(checkoutdir)
    invoke(
        [
            'git', 'clone',
            '--branch', branchname,
            '--origin', tmpremotename,
            remoteuri, checkoutdir],
        subprocess.check_call)

    invoke(
        ['git', 'config', 'gcrypt.gpg-args', gcryptgpgargs],
        subprocess.check_call, cwd=checkoutdir)

    # We intentionally don't check the return value here;
    # if it fails, assume the remote doesn't already exist
    invoke(
        ['git', 'remote', 'remove', tmpremotename],
        subprocess.call, cwd=checkoutdir)

    invoke(
        ['git', 'remote', 'add', remotename, gcrypturi],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'fetch', remotename],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'checkout', '-b', tmpbranch, f'{remotename}/{branchname}'],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-D', branchname],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-m', tmpbranch, branchname],
        subprocess.check_call, cwd=checkoutdir)

    if postdecscr:
        invoke(os.path.join(checkoutdir, postdecscr), subprocess.check_call)


def testsecunlock(checkoutdir, postdecscr):
    """Test whether the secrets repo is unlocked"""
    result = os.path.exists(os.path.join(checkoutdir, postdecscr))
    logger.info(f"Secrets is unlocked: {result}")
    return result


def parseargs(*args, **kwargs):  # pylint: disable=W0613
    """Parse command-line arguments"""

    parser = argparse.ArgumentParser(
        description="Handle PSYOPS secrets")
    subparsers = parser.add_subparsers(dest="action")
    subparsers.required = True

    parser.add_argument(
        "--debug", '-d', action='store_true', help="Include debugging output")

    parser.add_argument(
        '--import-secret-key', dest="gpgseckey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_SECRET_KEY"),
        help="Path to a secret GPG key to import")
    parser.add_argument(
        '--import-public-key', dest="gpgpubkey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_PUBLIC_KEY"),
        help="Path to a public GPG key to import")
    parser.add_argument(
        '--import-ownertrust-db', dest="gpgotrust", type=ResolvedPath,
        default=os.environ.get("PSYOPS_GPG_IMPORT_OWNERTRUST_DB"),
        help="Path to a GPG ownertrust database to import")
    parser.add_argument(
        '--gpg-secret-key-id', dest="gpgseckeyid",
        default=os.environ.get("PSYOPS_GPG_SECRET_KEY_ID"),
        help="Key ID for the secret GPG key")
    parser.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_ENCRYPTED_PRIVATE_KEY_PATH"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    parser.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_DECRYPTED_PRIVATE_KEY_PATH"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    parser.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_PUBLIC_KEY_PATH"),
        help="Location to save the SSH public key")
    parser.add_argument(
        '--git-branch', dest="gitbranch",
        default=os.environ.get("PSYOPS_SECRETS_REPO_BRANCH"),
        help=(
            "Name of the git branch to use for encrypted commits; must be name of both local "
            "branch we'll check out AND remote branch that is encrypted before having been "
            "pushed"))
    parser.add_argument(
        '--git-remote', dest="gitremote",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_NAME"),
        help="Name to use for the gcrypt remote")
    parser.add_argument(
        '--git-local-repository', dest="gitrepolocal", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SECRETS_REPO_CHECKOUT_PATH"),
        help=(
            "The local path to the git-remote-gcrypt repository, "
            "assumed to have already been cloned but not decrypted"))
    parser.add_argument(
        '--git-remote-uri', dest="gitremoteuri",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_URI"),
        help="URI for the gcrypt remote")
    parser.add_argument(
        '--secrets-post-decrypt-script', dest='postdecryptscript',
        default=os.environ.get("PSYOPS_SECRETS_POST_DECRYPT_SCRIPT_PATH"),
        help=(
            "The location of a script, relative to the secrets checkout dir, to run after "
            "decrypting. Also used as a test for whether the repo has been decrypted."))

    subparsers.add_parser(
        'unlock', help='Unlock a repo encrypted with git-remote-gcrypt')

    subparsers.add_parser(
        'testlock',
        help=(
            "Exit with zero code if the secrets repository unlocked (decrypted), "
            "or nonzero if it is locked (encrypted)"))

    subparsers.add_parser(
        'refreshagent',
        help=(
            "Sign a message with the private GPG key, to refresh the agent TTL "
            "(or to re-prompt for a passphrase if the TTL has expired)."))

    subparsers.add_parser(
        'importgpgkey',
        help=(
            "Import a GPG private key, public key, and owner trust database. "
            "Intended for setting up a new, *unconfigured* GPG instance; "
            "not tested with an existing ~/.gnupg directory."))

    subparsers.add_parser(
        'decryptsshkey',
        help=(
            "Decrypt an SSH key encrypted with the GPG passphrase; "
            "assumes an existing imported private GPG key."))

    return parser.parse_args()


def main(*args, **kwargs):
    """Main program execution"""

    parsed = parseargs(args, kwargs)

    # Configure umask for the rest of the script, including forked processes and file writes
    os.umask(0o0077)

    if parsed.debug:
        sys.excepthook = idb_excepthook
        logger.setLevel(logging.DEBUG)
        logger.info(parsed)

    if parsed.action == "unlock":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)
        decryptsshkey(parsed.sshenckey, parsed.sshdecpath, parsed.sshpubpath)
        secretssetup(
            parsed.gitrepolocal, parsed.gitremote,
            parsed.gitremoteuri, parsed.gitbranch,
            postdecscr=parsed.postdecryptscript)

    elif parsed.action == "testlock":
        # The 'not' turns boolean True=1 and False=0 into expected return codes
        # True=zero and False=nonzero
        return not testsecunlock(parsed.gitrepolocal, parsed.postdecryptscript)

    elif parsed.action == "refreshagent":
        testgpgsign(parsed.gpgseckeyid)

    elif parsed.action == "importgpgkey":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)

    elif parsed.action == "decryptsshkey":
        decryptsshkey(parsed.sshenckey, parsed.sshdecpath, parsed.sshpubpath)

    else:
        raise Exception(f"No handler for action '{parsed.action}'")


if __name__ == '__main__':
    sys.exit(main(*sys.argv))

#!/usr/bin/env python3

import argparse
import getpass
import logging
import os
import shutil
import subprocess
import sys


scriptdir = os.path.dirname(os.path.realpath(__file__))


# Helpers

def getlogger():
    log = logging.getLogger('wrapdocker')
    log.setLevel(logging.WARNING)
    conhandler = logging.StreamHandler()
    conhandler.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
    log.addHandler(conhandler)
    return log


log = getlogger()


def ResolvedPath(path):
    """Resolve a path

    Intended to be passed as a type= option to add_argument
    """
    return os.path.realpath(os.path.normpath(os.path.expanduser(path)))


def strace():
    import pdb
    pdb.set_trace()


def homedir():
    for varname in ["HOME", "USERPROFILE"]:
        home = os.environ.get(varname)
        if home:
            log.info(f"Found homedir '{home}' from {varname} environment variable")
        return home
    raise Exception("Could not determine home directory - try setting a $HOME or %USERPROFILE% variable")


def invoke(command, runner, env=None, cwd=None):
    """Stupid runner that logs for simple cases

    command: A commandline as a string arra, like ['ls', '/tmp']
    runner: Something that takes a commandline, such as subprocess.check_call
    env: An optional environment to pass to the command
    cwd: An optional working directory to pass to the command
    """
    log.info(f"Calling command {command} with environment {env} from cwd {cwd} via runner {runner}")
    return runner(command, env=env, cwd=cwd)


# Implementation functions

def testgpgpass(passphrase, keyid):
    """ Test GPG secret key passphrase

    Assume the secret key has been imported.
    """

    gpgcall = [
        'gpg', '--no-use-agent', '--batch', '--sign',
        '--passphrase', passphrase,
        '--default-key', keyid]
    log.info(f"Testing GPG passphrase with command '{gpgcall}'")
    gpgproc = subprocess.Popen(
        gpgcall, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
        stdin=subprocess.PIPE)
    try:
        outs, errs = gpgproc.communicate(input=b"TEST MESSAGE", timeout=2)
    except subprocess.TimeoutExpired:
        gpgproc.kill()
    log.info(f"GPG returned code {gpgproc.returncode}")
    return gpgproc.returncode == 0


def testseckeyimported(keyid):
    """ Test whether a secret key with the given key ID exists on the GPG keyring
    """
    output = invoke(['gpg', '--list-secret-keys'], subprocess.check_output)
    result = keyid in output.decode()
    log.info(f"Secret key imported: {result}")
    return result


def gpgimportkeys(secretkey, publickey, ownertrustdb):
    """ Import GPG keys

    - Will do nothing if the keys already exist
    - Does not require the passphrase to import, only to use after importing
    """
    log.info(
        "Attempting to import secret key {secretkey}, public key {publickey}, and owner trust database {ownertrustdb}")
    invoke(['gpg', '--batch', '--import', secretkey], subprocess.call)
    invoke(['gpg', '--batch', '--import', publickey], subprocess.call)
    invoke(['gpg', '--batch', '--import-ownertrust', ownertrustdb], subprocess.call)


def decryptsshkey(passphrase, encryptedkey, decryptedpath, pubkeypath):
    """ Decrypt an SSH key encrypted from a GPG private key

    (NOTE: This is NOT the same as an SSH private key was encrypted with ssh-keygen)
    passphrase:     Passphrase to the *GPG* private key
    encryptedkey:   Path to encrypted SSH private key
    decryptedpath:  Path to save the decrypted SSH private key
    pubkeypath:     Path to save the public key, which we generate from the private key after decrypting
    """

    log.info(f"Attempting to decrypt SSH key")

    invoke(
        [
            'gpg', '--batch', '--decrypt',
            '--passphrase', passphrase,
            '--output', decryptedpath,
            encryptedkey],
        subprocess.check_call)

    os.chmod(decryptedpath, 0o0600)

    # Regenerate the public key from the private key:
    pubkey = invoke(
        ['ssh-keygen', '-y', '-f', decryptedpath], subprocess.check_output)
    with open(pubkeypath, 'w') as pkf:
        pkf.write(pubkey.decode())

    # pkf = open(pubkeypath, 'w')
    # try:
    #     log.info(f"Attempting to write SSH public key to {pubkeypath}")
    #     pkf.write("")
    #     invoke(
    #         ['ssh-keygen', '-y', '-f', decryptedpath],
    #         subprocess.check_call, stdout=pkf)
    # finally:
    #     pkf.close()


def secretssetup(
        checkoutdir, passfile, remotename, remoteuri, branchname,
        postdecscr=None):
    """Clone secrets repository and decrypt it with git-remote-gcrypt

    checkoutdir: The local checkout path
    passfile:    A file containing the GPG passphrase
    remotename:  Name of the git remote
    remoteuri:   Bare (without the 'gcrypt::' prefix) URI for the gcrypt remote
    branchname:  Name of the git branch; local and remote branch *must* use
                 same name
    postdecscr:  A relative path to a script to run after decrypting the repo
    """

    tmpbranch = f'{branchname}-tmp'
    tmpremotename = f'{remotename}-tmp'
    gcrypturi = f'gcrypt::{remoteuri}'

    log.info(f"Attempting to setup secrets for checkout dir {checkoutdir} using passfile at {passfile} for git remote name {remotename} and URI {remoteuri} and branch name {branchname}. Afterwards, will run a script at: {postdecscr}.")

    gcryptgpgargs = f'--batch --no-tty --passphrase-file {passfile}'

    if os.path.exists(checkoutdir):
        shutil.rmtree(checkoutdir)
    invoke(
        [
            'git', 'clone',
            '--branch', branchname,
            '--origin', tmpremotename,
            remoteuri, checkoutdir],
        subprocess.check_call)

    invoke(
        ['git', 'config', 'gcrypt.gpg-args', gcryptgpgargs],
        subprocess.check_call, cwd=checkoutdir)

    # We intentionally don't check the return value. If it fails, assume the remote doesn't already exist
    invoke(
        ['git', 'remote', 'remove', tmpremotename],
        subprocess.call, cwd=checkoutdir)

    invoke(
        ['git', 'remote', 'add', remotename, gcrypturi],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'fetch', remotename],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'checkout', '-b', tmpbranch, f'{remotename}/{branchname}'],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-D', branchname],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-m', tmpbranch, branchname],
        subprocess.check_call, cwd=checkoutdir)

    if postdecscr:
        invoke(os.path.join(checkoutdir, postdecscr), subprocess.check_call)


def testsecunlock(checkoutdir, postdecscr):
    result = os.path.exists(os.path.join(checkoutdir, postdecscr))
    log.info(f"Secrets is unlocked: {result}")
    return result


def iagetgpgpassphrase(keyid, maxtries=5):
    ctr = 1
    success = False
    # Don't loop forever in `while` because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
    while ctr <= maxtries:
        passphrase = getpass.getpass(f'Enter passphrase for secret key (id {keyid}) (attempt {ctr}/{maxtries}): ')
        log.info(passphrase)
        if testgpgpass(passphrase, keyid):
            success = True
            break
        ctr += 1
    return passphrase if success else False


def savegpgpassfile(passfile, passphrase):
    log.info(f"Attempting to write GPG passphrase to file {passfile}")
    with open(passfile, 'w') as pf:
        pf.write(passphrase)


def readgpgpassfile(passfile):
    log.info(f"Attempting to read GPG passphrase from file {passfile}")
    with open(passfile) as pf:
        passphrase = pf.read()
    return passphrase


def resolvegpgpass(keyid, passphrase, passfile, maxtries=5):

    goodpass = None

    if passphrase and testgpgpass(passphrase, keyid):
        log.info("Found valid GPG passphrase from CLI argument")
        goodpass = passphrase

    if not goodpass and passfile:
        passfile = ResolvedPath(passfile)
        if os.path.exists(passfile):
            passphrase = readgpgpassfile(passfile)
            if testgpgpass(passphrase, keyid):
                log.info(
                    f"Found valid GPG passphrase from passfile at {passfile}")
                goodpass = passphrase

    if not goodpass:
        passphrase = iagetgpgpassphrase(keyid)
        if passphrase:
            log.info("Received valid GPG passphrase from interactive prompt")
            goodpass = passphrase

    if goodpass:
        return goodpass
    else:
        msg = "Could not resolve GPG passphrase"
        log.info(msg)
        raise Exception(msg)


def parseargs(*args, **kwargs):
    parser = argparse.ArgumentParser(
        description="Handle PSYOPS secrets")
    subparsers = parser.add_subparsers(dest="action")
    subparsers.required = True

    parser.add_argument(
        "--debug", '-d', action='store_true', help="Include debugging output")

    parser.add_argument(
        '--import-secret-key', dest="gpgseckey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_SECRET_KEY"),
        help="Path to a secret GPG key to import")
    parser.add_argument(
        '--import-public-key', dest="gpgpubkey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_PUBLIC_KEY"),
        help="Path to a public GPG key to import")
    parser.add_argument(
        '--import-ownertrust-db', dest="gpgotrust", type=ResolvedPath,
        default=os.environ.get("PSYOPS_GPG_IMPORT_OWNERTRUST_DB"),
        help="Path to a GPG ownertrust database to import")
    parser.add_argument(
        '--gpg-secret-key-id', dest="gpgseckeyid",
        default=os.environ.get("PSYOPS_GPG_SECRET_KEY_ID"),
        help="Key ID for the secret GPG key")
    # parser.add_argument(
    #     '--gpg-public-key-id', dest="gpgpubkeyid",
    #     default=os.environ.get("PSYOPS_GPG_PUBLIC_KEY_ID"),
    #     help="Key ID for the public GPG key")
    parser.add_argument(
        '--gpg-passphrase-file', dest="gpgpassfile", type=ResolvedPath,
        default=os.environ.get("PSYOPS_GPG_PLAINTEXT_PASSFILE"),
        help="A file to contain the GPG passphrase. If it exists and is valid, we use it; otherwise we save the passphrase to it for future use. Note that if --gpg-passphrase is passed, this overrides it.")
    parser.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_ENCRYPTED_PRIVATE_KEY_PATH"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    parser.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_DECRYPTED_PRIVATE_KEY_PATH"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    parser.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_PUBLIC_KEY_PATH"),
        help="Location to save the SSH public key")
    parser.add_argument(
        '--git-branch', dest="gitbranch",
        default=os.environ.get("PSYOPS_SECRETS_REPO_BRANCH"),
        help="Name of the git branch to use for encrypted commits; must be name of both local branch we'll check out AND remote branch that is encrypted before having been pushed")
    parser.add_argument(
        '--git-remote', dest="gitremote",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_NAME"),
        help="Name to use for the gcrypt remote")
    parser.add_argument(
        '--git-local-repository', dest="gitrepolocal", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SECRETS_REPO_CHECKOUT_PATH"),
        help="The local path to the git-remote-gcrypt repository, assumed to have already been cloned but not decrypted")
    parser.add_argument(
        '--git-remote-uri', dest="gitremoteuri",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_URI"),
        help="URI for the gcrypt remote")
    parser.add_argument(
        '--secrets-post-decrypt-script', dest='postdecryptscript',
        default=os.environ.get("PSYOPS_SECRETS_POST_DECRYPT_SCRIPT_PATH"),
        help="The location of a script, relative to the secrets checkout dir, to run after decrypting. Also used as a test for whether the repo has been decrypted.")

    # unlocksp = subparsers.add_parser(
    subparsers.add_parser(
        'unlock', help='Unlock a repo encrypted with git-remote-gcrypt')
    # testlocksp = subparsers.add_parser(
    subparsers.add_parser(
        'testlock',
        help='Exit with zero code if the secrets repository unlocked (decrypted), or nonzero if it is locked (encrypted)')
    # importgpgkeysp = subparsers.add_parser(
    subparsers.add_parser(
        'importgpgkey',
        help="Import a GPG private key, public key, and owner trust database. Intended for setting up a new, *unconfigured* GPG instance; not tested with an existing ~/.gnupg directory.")
    # decsshksp = subparsers.add_parser(
    subparsers.add_parser(
        'decryptsshkey',
        help='Decrypt an SSH key encrypted with the GPG passphrase; assumes an existing imported private GPG key.')

    testpasssp = subparsers.add_parser(
        'testgpgpass',
        help="Test a GPG passphrase for an existing imported secret key")
    testpasssp.add_argument(
        '--gpg-passphrase', required=True, dest="gpgpass",
        help="Passphrase for the secret GPG key")

    return parser.parse_args()


def main(*args, **kwargs):
    parsed = parseargs(args, kwargs)

    if parsed.debug:
        log.setLevel(logging.DEBUG)
        log.info(parsed)

    if parsed.action == "unlock":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, None, parsed.gpgpassfile)

        # If either of those methods were successful, use the passphrase;
        # otherwise, do nothingty
        if passphrase:
            savegpgpassfile(parsed.gpgpassfile, passphrase)
            decryptsshkey(
                passphrase, parsed.sshenckey, parsed.sshdecpath,
                parsed.sshpubpath)
            secretssetup(
                parsed.gitrepolocal, parsed.gpgpassfile, parsed.gitremote,
                parsed.gitremoteuri, parsed.gitbranch,
                postdecscr=parsed.postdecryptscript)
        else:
            print("Could not decrypt GPG key based on the entered passphrase; continuing without decrypting secrets")

    elif parsed.action == "testlock":
        # The 'not' turns boolean True=1 and False=0 into expected return codes
        # True=zero and False=nonzero
        return not testsecunlock(parsed.gitrepolocal, parsed.postdecryptscript)

    elif parsed.action == "testgpgpass":
        if testgpgpass(parsed.gpgpass, parsed.gpgseckeyid):
            print("Correct passphrase")
        else:
            print("Incorrect passphrase")

    elif parsed.action == "importgpgkey":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)

    elif parsed.action == "decryptsshkey":
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, passphrase=parsed.gpgpass,
            passfile=parsed.gpgpassfile)
        decryptsshkey(
            parsed.gpgpass, parsed.sshenckey, parsed.sshdecpath,
            parsed.sshpubpath)

    else:
        raise Exception(f"No handler for action '{parsed.action}'")


if __name__ == '__main__':
    sys.exit(main(*sys.argv))

#!/usr/bin/env python3

import argparse
import getpass
import logging
import os
import subprocess
import sys


scriptdir = os.path.dirname(os.path.realpath(__file__))


# Helpers

def ResolvedPath(path):
    """Resolve a path

    Intended to be passed as a type= option to add_argument
    """
    return os.path.realpath(os.path.normpath(os.path.expanduser(path)))


def strace():
    import pdb
    pdb.set_trace()


def maybegetenv(variable):
    if variable and variable in os.environ.keys():
        return os.environ[variable]
    return None


def homedir():
    home = maybegetenv("HOME")
    if not home:
        home = maybegetenv("USERPROFILE")
    if not home:
        raise Exception("Could not determine home directory - try setting the $HOME or %USERPROFILE% variable")
    return home


# Implementation functions

def testgpgpass(passphrase, keyid):
    """ Test GPG secret key passphrase

    Assume the secret key has been imported.
    """

    gpgproc = subprocess.Popen(
        ['gpg', '--no-use-agent', '--batch', '--sign', '--passphrase', passphrase, '--default-key', keyid],
        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.PIPE)
    try:
        outs, errs = gpgproc.communicate(input=b"TEST MESSAGE", timeout=2)
    except subprocess.TimeoutExpired:
        gpgproc.kill()
    return gpgproc.returncode == 0


def testseckeyimported(keyid):
    """ Test whether a secret key with the given key ID exists on the GPG keyring
    """
    output = subprocess.check_output(['gpg', '--list-secret-keys'])
    return keyid in output.decode()


def gpgimportkeys(secretkey, publickey, ownertrustdb):
    """ Import GPG keys

    - Will do nothing if the keys already exist
    - Does not require the passphrase to import, only to use after importing
    """
    subprocess.call(['gpg', '--batch', '--import', secretkey])
    subprocess.call(['gpg', '--batch', '--import', publickey])
    subprocess.call(['gpg', '--batch', '--import-ownertrust', ownertrustdb])


def decryptsshkey(passphrase, encryptedkey, decryptedpath, pubkeypath):
    """ Decrypt an SSH key encrypted from a GPG private key

    (NOTE: This is NOT the same as an SSH private key was encrypted with ssh-keygen)
    passphrase:     Passphrase to the *GPG* private key
    encryptedkey:   Path to encrypted SSH private key
    decryptedpath:  Path to save the decrypted SSH private key
    pubkeypath:     Path to save the public key, which we generate from the private key after decrypting
    """

    subprocess.check_call(
        ['gpg', '--batch', '--decrypt', '--passphrase', passphrase, '--output', decryptedpath, encryptedkey])
    os.chmod(decryptedpath, 0o0600)

    # Regenerate the public key from the private key:
    pkf = open(pubkeypath, 'w')
    try:
        pkf.write("")
        subprocess.check_call(
            ['ssh-keygen', '-y', '-f', decryptedpath], stdout=pkf)
    finally:
        pkf.close()


def secretssetup(localrepo, passfile, remotename, remoteuri, branchname, clonefirst=False):
    """ Set up a cloned, but currently encrypted, secrets repository

    Assume a repo encrypted with git-remote-gcrypt was cloned locally as a
    regular git repository - that is, not through git-remote-gcrypt, and so not
    decrypted. Decrypt such a repository, and change the remote to a
    git-remote-gcrypt remote.

    localrepo:  A cloned gcrypt repo, where gcrypt has not yet been configured
    passfile:   A file containing the GPG passphrase
    remotename: Name of the git remote
    remoteuri:  Bare (without the 'gcrypt::' prefix) URI for the gcrypt remote
    branchname: Name of the git branch; local and remote branch *must* use same
                name
    clonefirst: If false (default), assume localrepo is already checked out
                encrypted. If true, check it out first.
    """

    tmpbranch = f'{branchname}-tmp'
    gcrypturi = f'gcrypt::{remoteuri}'

    if clonefirst:
        subprocess.check_call(['git', 'clone', remoteuri, localrepo])

    subprocess.check_call(
        ['git', 'config', 'gcrypt.gpg-args', f'--batch --no-tty --passphrase-file {passfile}'],
        cwd=localrepo)

    # We intentionally don't check the return value. If it fails, assume the remote doesn't already exist
    subprocess.call(['git', 'remote', 'remove', remotename], cwd=localrepo)

    subprocess.check_call(['git', 'remote', 'add', remotename, gcrypturi], cwd=localrepo)
    subprocess.check_call(['git', 'fetch', remotename], cwd=localrepo)
    subprocess.check_call(['git', 'checkout', '-b', tmpbranch, f'{remotename}/{branchname}'], cwd=localrepo)
    subprocess.check_call(['git', 'branch', '-D', branchname], cwd=localrepo)
    subprocess.check_call(['git', 'branch', '-m', tmpbranch, branchname], cwd=localrepo)


def iagetgpgpassphrase(keyid, maxtries=5):
    ctr = 1
    success = False
    # Don't loop forever in `while` because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
    while ctr <= maxtries:
        passphrase = getpass.getpass(f'Enter passphrase for secret key (id {keyid}) (attempt {ctr}/{maxtries}): ')
        logging.info(passphrase)
        if testgpgpass(passphrase, keyid):
            success = True
            break
        ctr += 1
    return passphrase if success else False


def savegpgpassfile(passfile, passphrase):
    with open(passfile, 'w') as pf:
        pf.write(passphrase)


def readgpgpassfile(passfile):
    with open(passfile) as pf:
        passphrase = pf.read()
    return passphrase


def resolvegpgpass(keyid, passphrase, passfile, maxtries=5):

    goodpass = None

    if passphrase and testgpgpass(passphrase, keyid):
        goodpass = passphrase

    if not goodpass and passfile:
        passfile = ResolvedPath(passfile)
        if os.path.exists(passfile):
            passphrase = readgpgpassfile(passfile)
            if testgpgpass(passphrase, keyid):
                goodpass = passphrase

    if not goodpass:
        passphrase = iagetgpgpassphrase(keyid)
        if passphrase:
            goodpass = passphrase

    if goodpass:
        return goodpass
    else:
        raise Exception("Could not resolve GPG passphrase")


def parseargs(*args, **kwargs):
    parser = argparse.ArgumentParser(
        description="Handle PSYOPS secrets")
    subparsers = parser.add_subparsers(dest="action")
    subparsers.required = True

    parser.add_argument(
        "--debug", action='store_true', help="Include debugging output")

    unlocksp = subparsers.add_parser('unlock', help='Unlock a git-remote-gcrypt -encrypted repository')
    unlocksp.add_argument(
        '--import-secret-key', required=True, dest="gpgseckey", type=ResolvedPath,
        help="Path to a secret GPG key to import")
    unlocksp.add_argument(
        '--import-public-key', required=True, dest="gpgpubkey", type=ResolvedPath,
        help="Path to a public GPG key to import")
    unlocksp.add_argument(
        '--import-ownertrust-db', required=True, dest="gpgotrust", type=ResolvedPath,
        help="Path to a GPG ownertrust database to import")
    unlocksp.add_argument(
        '--gpg-secret-key-id', required=True, dest="gpgseckeyid",
        help="Key ID for the secret GPG key")
    # unlocksp.add_argument(
    #     '--gpg-public-key-id', required=True, dest="gpgpubkeyid",
    #     help="Key ID for the public GPG key")
    unlocksp.add_argument(
        '--gpg-passphrase-file', dest="gpgpassfile", type=ResolvedPath,
        default=os.path.join(homedir(), ".gpg.passphrase",),
        help="A file to contain the GPG passphrase. If it exists and is valid, we use it; otherwise we save the passphrase to it for future use. Note that if --gpg-passphrase is passed, this overrides it.")
    unlocksp.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519.gpg"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    unlocksp.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    unlocksp.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519.pub"),
        help="Location to save the SSH public key")
    unlocksp.add_argument(
        '--git-branch', default="master", dest="gitbranch",
        help="Name of the git branch to use for encrypted commits; must be name of both local branch we'll check out AND remote branch that is encrypted before having been pushed")
    unlocksp.add_argument(
        '--git-remote', default="origin", dest="gitremote",
        help="Name to use for the gcrypt remote")
    unlocksp.add_argument(
        '--git-local-repository', required=True, dest="gitrepolocal", type=ResolvedPath,
        help="The local path to the git-remote-gcrypt repository, assumed to have already been cloned but not decrypted")
    unlocksp.add_argument(
        '--git-remote-uri', required=True, dest="gitremoteuri",
        help="URI for the gcrypt remote")
    unlocksp.add_argument(
        '--clone-first', action='store_true', dest="clonefirst",
        help="Clone the SSH repo (otherwise assume it is already cloned)")

    testpasssp = subparsers.add_parser(
        'testgpgpass',
        help="Test a GPG passphrase for an existing imported secret key")
    testpasssp.add_argument(
        '--gpg-secret-key-id', required=True, dest="gpgseckeyid",
        help="Key ID for the secret GPG key")
    testpasssp.add_argument(
        '--gpg-passphrase', required=True, dest="gpgpass",
        help="Passphrase for the secret GPG key")

    importgpgkeysp = subparsers.add_parser(
        'importgpgkey',
        help="Import a GPG private key, public key, and owner trust database. Intended for setting up a new, *unconfigured* GPG instance; not tested with an existing ~/.gnupg directory.")
    importgpgkeysp.add_argument(
        '--import-secret-key', required=True, dest="gpgseckey", type=ResolvedPath,
        help="Path to a secret GPG key to import")
    importgpgkeysp.add_argument(
        '--import-public-key', required=True, dest="gpgpubkey", type=ResolvedPath,
        help="Path to a public GPG key to import")
    importgpgkeysp.add_argument(
        '--import-ownertrust-db', required=True, dest="gpgotrust", type=ResolvedPath,
        help="Path to a GPG ownertrust database to import")

    decsshksp = subparsers.add_parser(
        'decryptsshkey',
        help='Decrypt an SSH key encrypted with the GPG passphrase; assumes an existing imported private GPG key.')
    decsshksp.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519.gpg"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    decsshksp.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    decsshksp.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=ResolvedPath,
        default=os.path.join(homedir(), ".ssh", "id_ed25519.pub"),
        help="Location to save the SSH public key")
    decsshksp.add_argument(
        '--gpg-passphrase', default=maybegetenv("PSYOPS_SECRETS_GPG_PASSPHRASE"), dest="gpgpass",
        help="Passphrase for the secret GPG key. Defaults to $PSYOPS_SECRETS_GPG_PASSPHRASE.")
    decsshksp.add_argument(
        '--gpg-passphrase-file', dest="gpgpassfile", type=ResolvedPath,
        default=os.path.join(homedir(), ".gpg.passphrase",),
        help="Key ID for the public GPG key")
    decsshksp.add_argument(
        '--gpg-secret-key-id', required=True, dest="gpgseckeyid",
        help="Key ID for the secret GPG key")

    return parser.parse_args()


def main(*args, **kwargs):
    logging.basicConfig()
    parsed = parseargs(args, kwargs)

    if parsed.debug:
        logging.root.setLevel(logging.DEBUG)

    if parsed.action == "unlock":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, None, parsed.gpgpassfile)

        # If either of those methods were successful, use the passphrase;
        # otherwise, do nothingty
        if passphrase:
            savegpgpassfile(parsed.gpgpassfile, passphrase)
            decryptsshkey(
                passphrase, parsed.sshenckey, parsed.sshdecpath,
                parsed.sshpubpath)
            secretssetup(
                parsed.gitrepolocal, parsed.gpgpassfile, parsed.gitremote,
                parsed.gitremoteuri, parsed.gitbranch, parsed.clonefirst)
        else:
            print("Could not decrypt GPG key based on the entered passphrase; continuing without decrypting secrets")

    elif parsed.action == "testgpgpass":
        if testgpgpass(parsed.gpgpass, parsed.gpgseckeyid):
            print("Correct passphrase")
        else:
            print("Incorrect passphrase")

    elif parsed.action == "importgpgkey":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)

    elif parsed.action == "decryptsshkey":
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, passphrase=parsed.gpgpass,
            passfile=parsed.gpgpassfile)
        decryptsshkey(
            parsed.gpgpass, parsed.sshenckey, parsed.sshdecpath,
            parsed.sshpubpath)

    else:
        raise Exception(f"No handler for action '{parsed.action}'")


if __name__ == '__main__':
    sys.exit(main(*sys.argv))

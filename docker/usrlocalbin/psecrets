#!/usr/bin/env python3

"""psecrets: manage PSYOPS secrets"""

import argparse
import getpass
import logging
import os
import shutil
import subprocess
import sys


scriptdir = os.path.dirname(os.path.realpath(__file__))  # pylint: disable=C0103
logger = logging.getLogger(__name__)  # pylint: disable=C0103


# Helpers

class ResolvedPath(str):
    """Resolve a path

    Intended to be passed as a type= option to add_argument()
    (which is why it is a class and not a function)
    """
    def __new__(cls, path):
        return str.__new__(cls, os.path.realpath(os.path.normpath(os.path.expanduser(path))))


def homedir():
    """Find the homedir, crossplatformly"""
    for varname in ["HOME", "USERPROFILE"]:
        home = os.environ.get(varname)
        if home:
            logger.info(f"Found homedir '{home}' from {varname} environment variable")
        return home
    raise Exception(
        "Could not determine home directory - try setting a $HOME or %USERPROFILE% variable")


def invoke(command, runner, env=None, cwd=None):
    """Stupid runner that logs for simple cases

    command: A commandline as a string array, like ['ls', '/tmp']
    runner: Something that takes a commandline, such as subprocess.check_call
    env: An optional environment to pass to the command
    cwd: An optional working directory to pass to the command
    """
    logger.info(
        f"Calling command {command} with environment {env} "
        f"from cwd {cwd} via runner {runner}")
    return runner(command, env=env, cwd=cwd)


# Implementation functions

def testgpgpass(passphrase, keyid):
    """ Test GPG secret key passphrase

    Assume the secret key has been imported.
    """

    gpgcall = [
        'gpg', '--no-use-agent', '--batch', '--sign',
        '--passphrase', passphrase,
        '--default-key', keyid]
    logger.info(f"Testing GPG passphrase with command '{gpgcall}'")
    gpgproc = subprocess.Popen(
        gpgcall, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
        stdin=subprocess.PIPE)
    try:
        # outs, errs = gpgproc.communicate(input=b"TEST MESSAGE", timeout=2)
        gpgproc.communicate(input=b"TEST MESSAGE", timeout=2)
    except subprocess.TimeoutExpired:
        gpgproc.kill()
    logger.info(f"GPG returned code {gpgproc.returncode}")
    return gpgproc.returncode == 0


def testseckeyimported(keyid):
    """ Test whether a secret key with the given key ID exists on the GPG keyring
    """
    output = invoke(['gpg', '--list-secret-keys'], subprocess.check_output)
    result = keyid in output.decode()
    logger.info(f"Secret key imported: {result}")
    return result


def gpgimportkeys(secretkey, publickey, ownertrustdb):
    """ Import GPG keys

    - Will do nothing if the keys already exist
    - Does not require the passphrase to import, only to use after importing
    """
    logger.info(
        f"Attempting to import secret key {secretkey}, public key {publickey}, "
        f"and owner trust database {ownertrustdb}")
    invoke(['gpg', '--batch', '--import', secretkey], subprocess.call)
    invoke(['gpg', '--batch', '--import', publickey], subprocess.call)
    invoke(['gpg', '--batch', '--import-ownertrust', ownertrustdb], subprocess.call)


def decryptsshkey(passphrase, encryptedkey, decryptedpath, pubkeypath):
    """ Decrypt an SSH key encrypted from a GPG private key

    (NOTE: This is NOT the same as an SSH private key was encrypted with ssh-keygen)
    passphrase:     Passphrase to the *GPG* private key
    encryptedkey:   Path to encrypted SSH private key
    decryptedpath:  Path to save the decrypted SSH private key
    pubkeypath:     Path to save the public key, which we generate from the private key after
                    decrypting
    """

    logger.info(f"Attempting to decrypt SSH key")

    invoke(
        [
            'gpg', '--batch', '--decrypt',
            '--passphrase', passphrase,
            '--output', decryptedpath,
            encryptedkey],
        subprocess.check_call)

    # Regenerate the public key from the private key:
    pubkey = invoke(
        ['ssh-keygen', '-y', '-f', decryptedpath], subprocess.check_output)
    with open(pubkeypath, 'w') as pkf:
        pkf.write(pubkey.decode())


def secretssetup(
        checkoutdir, passfile, remotename, remoteuri, branchname,
        postdecscr=None):
    """Clone secrets repository and decrypt it with git-remote-gcrypt

    checkoutdir: The local checkout path
    passfile:    A file containing the GPG passphrase
    remotename:  Name of the git remote
    remoteuri:   Bare (without the 'gcrypt::' prefix) URI for the gcrypt remote
    branchname:  Name of the git branch; local and remote branch *must* use
                 same name
    postdecscr:  A relative path to a script to run after decrypting the repo
    """

    tmpbranch = f'{branchname}-tmp'
    tmpremotename = f'{remotename}-tmp'
    gcrypturi = f'gcrypt::{remoteuri}'

    logger.info(
        f"Attempting to setup secrets for checkout dir {checkoutdir} "
        f"using passfile at {passfile} for git remote name {remotename} and URI {remoteuri} "
        f"and branch name {branchname}. Afterwards, will run a script at: {postdecscr}.")

    gcryptgpgargs = f'--batch --no-tty --passphrase-file {passfile}'

    if os.path.exists(checkoutdir):
        shutil.rmtree(checkoutdir)
    invoke(
        [
            'git', 'clone',
            '--branch', branchname,
            '--origin', tmpremotename,
            remoteuri, checkoutdir],
        subprocess.check_call)

    invoke(
        ['git', 'config', 'gcrypt.gpg-args', gcryptgpgargs],
        subprocess.check_call, cwd=checkoutdir)

    # We intentionally don't check the return value here;
    # if it fails, assume the remote doesn't already exist
    invoke(
        ['git', 'remote', 'remove', tmpremotename],
        subprocess.call, cwd=checkoutdir)

    invoke(
        ['git', 'remote', 'add', remotename, gcrypturi],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'fetch', remotename],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'checkout', '-b', tmpbranch, f'{remotename}/{branchname}'],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-D', branchname],
        subprocess.check_call, cwd=checkoutdir)
    invoke(
        ['git', 'branch', '-m', tmpbranch, branchname],
        subprocess.check_call, cwd=checkoutdir)

    if postdecscr:
        invoke(os.path.join(checkoutdir, postdecscr), subprocess.check_call)


def testsecunlock(checkoutdir, postdecscr):
    """Test whether the secrets repo is unlocked"""
    result = os.path.exists(os.path.join(checkoutdir, postdecscr))
    logger.info(f"Secrets is unlocked: {result}")
    return result


def iagetgpgpassphrase(keyid, maxtries=5):
    """Interactively get GPG passphrase from STDIN"""
    ctr = 1
    success = False
    # Don't loop forever in `while` because ctrl-c will just pause Docker without launching a shell
    # and you'll have to kill the docker process and try again
    while ctr <= maxtries:
        passphrase = getpass.getpass(
            f'Enter passphrase for secret key (id {keyid}) (attempt {ctr}/{maxtries}): ')
        logger.info(passphrase)
        if testgpgpass(passphrase, keyid):
            success = True
            break
        ctr += 1
    return passphrase if success else False


def savegpgpassfile(passfile, passphrase):
    """Save the GPG passphrase to a file"""
    logger.info(f"Attempting to write GPG passphrase to file {passfile}")
    with open(passfile, 'w') as pfh:
        pfh.write(passphrase)


def readgpgpassfile(passfile):
    """Read the GPG passphrase from a file"""
    logger.info(f"Attempting to read GPG passphrase from file {passfile}")
    with open(passfile) as pfh:
        passphrase = pfh.read()
    return passphrase


def resolvegpgpass(keyid, passphrase, passfile):
    """Find the GPG passphrase; if not available, ask the user for it"""

    goodpass = None

    if passphrase and testgpgpass(passphrase, keyid):
        logger.info("Found valid GPG passphrase from CLI argument")
        goodpass = passphrase

    if not goodpass and passfile:
        passfile = ResolvedPath(passfile)
        if os.path.exists(passfile):
            passphrase = readgpgpassfile(passfile)
            if testgpgpass(passphrase, keyid):
                logger.info(
                    f"Found valid GPG passphrase from passfile at {passfile}")
                goodpass = passphrase

    if not goodpass:
        passphrase = iagetgpgpassphrase(keyid)
        if passphrase:
            logger.info("Received valid GPG passphrase from interactive prompt")
            goodpass = passphrase

    if goodpass:
        return goodpass
    else:
        msg = "Could not resolve GPG passphrase"
        logger.info(msg)
        raise Exception(msg)


def parseargs(*args, **kwargs):  # pylint: disable=W0613
    """Parse command-line arguments"""

    parser = argparse.ArgumentParser(
        description="Handle PSYOPS secrets")
    subparsers = parser.add_subparsers(dest="action")
    subparsers.required = True

    parser.add_argument(
        "--debug", '-d', action='store_true', help="Include debugging output")

    parser.add_argument(
        '--import-secret-key', dest="gpgseckey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_SECRET_KEY"),
        help="Path to a secret GPG key to import")
    parser.add_argument(
        '--import-public-key', dest="gpgpubkey",
        type=ResolvedPath, default=os.environ.get("PSYOPS_GPG_IMPORT_PUBLIC_KEY"),
        help="Path to a public GPG key to import")
    parser.add_argument(
        '--import-ownertrust-db', dest="gpgotrust", type=ResolvedPath,
        default=os.environ.get("PSYOPS_GPG_IMPORT_OWNERTRUST_DB"),
        help="Path to a GPG ownertrust database to import")
    parser.add_argument(
        '--gpg-secret-key-id', dest="gpgseckeyid",
        default=os.environ.get("PSYOPS_GPG_SECRET_KEY_ID"),
        help="Key ID for the secret GPG key")
    # parser.add_argument(
    #     '--gpg-public-key-id', dest="gpgpubkeyid",
    #     default=os.environ.get("PSYOPS_GPG_PUBLIC_KEY_ID"),
    #     help="Key ID for the public GPG key")
    parser.add_argument(
        '--gpg-passphrase-file', dest="gpgpassfile", type=ResolvedPath,
        default=os.environ.get("PSYOPS_GPG_PLAINTEXT_PASSFILE"),
        help=(
            "A file to contain the GPG passphrase. If it exists and is valid, we use it; "
            "otherwise we save the passphrase to it for future use. Note that if "
            "--gpg-passphrase is passed, this overrides it."))
    parser.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_ENCRYPTED_PRIVATE_KEY_PATH"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    parser.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_DECRYPTED_PRIVATE_KEY_PATH"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    parser.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SSH_PUBLIC_KEY_PATH"),
        help="Location to save the SSH public key")
    parser.add_argument(
        '--git-branch', dest="gitbranch",
        default=os.environ.get("PSYOPS_SECRETS_REPO_BRANCH"),
        help=(
            "Name of the git branch to use for encrypted commits; must be name of both local "
            "branch we'll check out AND remote branch that is encrypted before having been "
            "pushed"))
    parser.add_argument(
        '--git-remote', dest="gitremote",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_NAME"),
        help="Name to use for the gcrypt remote")
    parser.add_argument(
        '--git-local-repository', dest="gitrepolocal", type=ResolvedPath,
        default=os.environ.get("PSYOPS_SECRETS_REPO_CHECKOUT_PATH"),
        help=(
            "The local path to the git-remote-gcrypt repository, "
            "assumed to have already been cloned but not decrypted"))
    parser.add_argument(
        '--git-remote-uri', dest="gitremoteuri",
        default=os.environ.get("PSYOPS_SECRETS_REPO_REMOTE_URI"),
        help="URI for the gcrypt remote")
    parser.add_argument(
        '--secrets-post-decrypt-script', dest='postdecryptscript',
        default=os.environ.get("PSYOPS_SECRETS_POST_DECRYPT_SCRIPT_PATH"),
        help=(
            "The location of a script, relative to the secrets checkout dir, to run after "
            "decrypting. Also used as a test for whether the repo has been decrypted."))

    # unlocksp = subparsers.add_parser(
    subparsers.add_parser(
        'unlock', help='Unlock a repo encrypted with git-remote-gcrypt')
    # testlocksp = subparsers.add_parser(
    subparsers.add_parser(
        'testlock',
        help=(
            "Exit with zero code if the secrets repository unlocked (decrypted), "
            "or nonzero if it is locked (encrypted)"))
    # importgpgkeysp = subparsers.add_parser(
    subparsers.add_parser(
        'importgpgkey',
        help=(
            "Import a GPG private key, public key, and owner trust database. "
            "Intended for setting up a new, *unconfigured* GPG instance; "
            "not tested with an existing ~/.gnupg directory."))
    # decsshksp = subparsers.add_parser(
    subparsers.add_parser(
        'decryptsshkey',
        help=(
            "Decrypt an SSH key encrypted with the GPG passphrase; "
            "assumes an existing imported private GPG key."))

    testpasssp = subparsers.add_parser(
        'testgpgpass',
        help="Test a GPG passphrase for an existing imported secret key")
    testpasssp.add_argument(
        '--gpg-passphrase', required=True, dest="gpgpass",
        help="Passphrase for the secret GPG key")

    return parser.parse_args()


def main(*args, **kwargs):
    """Main program execution"""

    parsed = parseargs(args, kwargs)

    # Configure umask for the rest of the script, including forked processes and file writes
    os.umask(0o0077)

    if parsed.debug:
        logger.setLevel(logging.DEBUG)
        logger.info(parsed)

    if parsed.action == "unlock":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, None, parsed.gpgpassfile)

        # If either of those methods were successful, use the passphrase;
        # otherwise, do nothingty
        if passphrase:
            savegpgpassfile(parsed.gpgpassfile, passphrase)
            decryptsshkey(
                passphrase, parsed.sshenckey, parsed.sshdecpath,
                parsed.sshpubpath)
            secretssetup(
                parsed.gitrepolocal, parsed.gpgpassfile, parsed.gitremote,
                parsed.gitremoteuri, parsed.gitbranch,
                postdecscr=parsed.postdecryptscript)
        else:
            print(
                "Could not decrypt GPG key based on the entered passphrase; "
                "continuing without decrypting secrets")

    elif parsed.action == "testlock":
        # The 'not' turns boolean True=1 and False=0 into expected return codes
        # True=zero and False=nonzero
        return not testsecunlock(parsed.gitrepolocal, parsed.postdecryptscript)

    elif parsed.action == "testgpgpass":
        if testgpgpass(parsed.gpgpass, parsed.gpgseckeyid):
            print("Correct passphrase")
        else:
            print("Incorrect passphrase")

    elif parsed.action == "importgpgkey":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)

    elif parsed.action == "decryptsshkey":
        passphrase = resolvegpgpass(
            parsed.gpgseckeyid, passphrase=parsed.gpgpass,
            passfile=parsed.gpgpassfile)
        decryptsshkey(
            parsed.gpgpass, parsed.sshenckey, parsed.sshdecpath,
            parsed.sshpubpath)

    else:
        raise Exception(f"No handler for action '{parsed.action}'")


if __name__ == '__main__':
    sys.exit(main(*sys.argv))

#!/usr/bin/env python3

import argparse
import getpass
import logging
import os
import subprocess
import sys


scriptdir = os.path.dirname(os.path.realpath(__file__))


# Helper functions

def strace():
    import pdb
    pdb.set_trace()


# Implementation functions

def testgpgpass(passphrase, keyid):
    """ Test GPG secret key passphrase

    Assume the secret key has been imported.
    """

    gpgproc = subprocess.Popen(
        ['gpg', '--no-use-agent', '--batch', '--sign', '--passphrase', passphrase, '--default-key', keyid],
        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.PIPE)
    try:
        outs, errs = gpgproc.communicate(input=b"TEST MESSAGE", timeout=2)
    except subprocess.TimeoutExpired:
        gpgproc.kill()
    return gpgproc.returncode == 0


def testseckeyimported(keyid):
    """ Test whether a secret key with the given key ID exists on the GPG keyring
    """
    output = subprocess.check_output(['gpg', '--list-secret-keys'])
    return keyid in output.decode()


def gpgimportkeys(secretkey, publickey, ownertrustdb):
    """ Import GPG keys

    - Will do nothing if the keys already exist
    - Does not require the passphrase to import, only to use after importing
    """
    subprocess.call(['gpg', '--batch', '--import', secretkey])
    subprocess.call(['gpg', '--batch', '--import', publickey])
    subprocess.call(['gpg', '--batch', '--import-ownertrust', ownertrustdb])


def decryptsshkey(passphrase, encryptedkey, decryptedpath, pubkeypath):
    """ Decrypt an SSH key encrypted from a GPG private key

    (NOTE: This is NOT the same as an SSH private key was encrypted with ssh-keygen)
    passphrase:     Passphrase to the *GPG* private key
    encryptedkey:   Path to encrypted SSH private key
    decryptedpath:  Path to save the decrypted SSH private key
    pubkeypath:     Path to save the public key, which we generate from the private key after decrypting
    """

    subprocess.check_call(
        ['gpg', '--batch', '--decrypt', '--passphrase', passphrase, '--output', decryptedpath, encryptedkey])
    os.chmod(decryptedpath, 0o0600)

    # Regenerate the public key from the private key:
    pkf = open(pubkeypath, 'w')
    try:
        pkf.write("")
        subprocess.check_call(
            ['ssh-keygen', '-y', '-f', decryptedpath], stdout=pkf)
    finally:
        pkf.close()


def secretssetup(localrepo, passfile, remotename, remoteuri, branchname):
    """ Set up the secrets repository
    localrepo:  A cloned gcrypt repo, where gcrypt has not yet been configured
    passfile:   A file containing the GPG passphrase
    remotename: Name of the git remote
    remoteuri:  URI for the gcrypt remote (like gcrypt::git@...)
    branchname: Name of the git branch; local and remote branch *must* use same name
    """

    tmpbranch = f'{branchname}-tmp'
    subprocess.check_call(['git', 'config', 'gcrypt.gpg-args', f'--batch --no-tty --passphrase-file {passfile}'], cwd=localrepo)

    # We intentionally don't check the return value. If it fails, assume the remote doesn't already exist
    subprocess.call(['git', 'remote', 'remove', remotename], cwd=localrepo)

    subprocess.check_call(['git', 'remote', 'add', remotename, remoteuri], cwd=localrepo)
    subprocess.check_call(['git', 'fetch', remotename], cwd=localrepo)
    subprocess.check_call(['git', 'checkout', '-b', tmpbranch, f'{remotename}/{branchname}'], cwd=localrepo)
    subprocess.check_call(['git', 'branch', '-D', branchname], cwd=localrepo)
    subprocess.check_call(['git', 'branch', '-m', tmpbranch, branchname], cwd=localrepo)


def iasavepassphrase(keyid, passfile, maxtries=5):
    """ Interactively save passphrase for GPG secret key

    Assumes GPG key has already been imported
    """
    ctr = 1
    success = False
    # Don't loop forever in `while` because ctrl-c will just pause Docker without launching a shell and you'll have to kill the docker process and try again
    while ctr <= maxtries:
        passphrase = getpass.getpass(f'Enter passphrase for secret key (id {keyid}) (attempt {ctr}/{maxtries}): ')
        logging.info(passphrase)
        if testgpgpass(passphrase, keyid):
            success = True
            with open(passfile, 'w') as pf:
                pf.write(passphrase)
            break
        ctr += 1
    return passphrase if success else False


def resolvedpath(path):
    """Resolve a path

    Intended to be passed as a type= option to add_argument
    """
    return os.path.realpath(os.path.normpath(os.path.expanduser(path)))


def parseargs(*args, **kwargs):
    parser = argparse.ArgumentParser(
        description="Handle PSYOPS secrets")
    subparsers = parser.add_subparsers(dest="action")
    subparsers.required = True

    parser.add_argument(
        "--debug", action='store_true', help="Include debugging output")

    unlocksp = subparsers.add_parser('unlock', help='Unlock a git-remote-gcrypt -encrypted repository')
    unlocksp.add_argument(
        '--import-secret-key', required=True, dest="gpgseckey", type=resolvedpath,
        help="Path to a secret GPG key to import")
    unlocksp.add_argument(
        '--import-public-key', required=True, dest="gpgpubkey", type=resolvedpath,
        help="Path to a public GPG key to import")
    unlocksp.add_argument(
        '--import-ownertrust-db', required=True, dest="gpgotrust", type=resolvedpath,
        help="Path to a GPG ownertrust database to import")
    unlocksp.add_argument(
        '--gpg-secret-key-id', required=True, dest="gpgseckeyid",
        help="Key ID for the secret GPG key")
    # unlocksp.add_argument(
    #     '--gpg-public-key-id', required=True, dest="gpgpubkeyid",
    #     help="Key ID for the public GPG key")
    unlocksp.add_argument(
        '--gpg-passphrase-file', dest="gpgpassfile", type=resolvedpath,
        default=os.path.join(os.environ['HOME'], ".gpg.passphrase'",),
        help="Key ID for the public GPG key")
    unlocksp.add_argument(
        '--ssh-encrypted-private-key', dest="sshenckey", type=resolvedpath,
        default=os.path.join(os.environ['HOME'], ".ssh", "id_ed25519.gpg"),
        help="Location for the SSH private key, encrypted with the GPG secret key")
    unlocksp.add_argument(
        '--ssh-decrypted-private-key', dest="sshdecpath", type=resolvedpath,
        default=os.path.join(os.environ['HOME'], ".ssh", "id_ed25519"),
        help="Location to save the plaintext SSH private key after decrypting with GPG secret key")
    unlocksp.add_argument(
        '--ssh-public-key', dest="sshpubpath", type=resolvedpath,
        default=os.path.join(os.environ['HOME'], ".ssh", "id_ed25519.pub"),
        help="Location to save the SSH public key")
    unlocksp.add_argument(
        '--git-branch', default="master", dest="gitbranch",
        help="Name of the git branch to use for encrypted commits; must be name of both local branch we'll check out AND remote branch that is encrypted before having been pushed")
    unlocksp.add_argument(
        '--git-remote', default="origin", dest="gitremote",
        help="Name to use for the gcrypt remote")
    unlocksp.add_argument(
        '--git-local-repository', required=True, dest="gitrepolocal", type=resolvedpath,
        help="The local path to the git-remote-gcrypt repository, assumed to have already been cloned but not decrypted")
    unlocksp.add_argument(
        '--git-remote-uri', required=True, dest="gitremoteuri",
        help="URI for the gcrypt remote")

    testpasssp = subparsers.add_parser('testgpgpass', help="Test a GPG passphrase for an existing imported secret key")
    testpasssp.add_argument(
        '--gpg-secret-key-id', required=True, dest="gpgseckeyid",
        help="Key ID for the secret GPG key")
    testpasssp.add_argument(
        '--gpg-passphrase', required=True, dest="gpgpass",
        help="Passphrase for the secret GPG key")

    return parser.parse_args()


def main(*args, **kwargs):
    logging.basicConfig()
    parsed = parseargs(args, kwargs)

    if parsed.debug:
        logging.root.setLevel(logging.DEBUG)

    if parsed.action == "unlock":
        gpgimportkeys(parsed.gpgseckey, parsed.gpgpubkey, parsed.gpgotrust)

        passphrase = None
        # First, check for good passphrase in existing gpgpassfile
        if os.path.exists(parsed.gpgpassfile):
            with open(parsed.gpgpassfile, 'rb') as pf:
                possiblepass = pf.read()
            if testgpgpass(possiblepass, parsed.gpgseckeyid):
                passphrase = possiblepass
        # Next, try to get the passphrase interactively
        if not passphrase:
            passphrase = iasavepassphrase(parsed.gpgseckeyid, parsed.gpgpassfile)
        # If either of those methods were successful, use the passphrase, otherwise do nothing
        if passphrase:
            decryptsshkey(passphrase, parsed.sshenckey, parsed.sshdecpath, parsed.sshpubpath)
            secretssetup(parsed.gitrepolocal, parsed.gpgpassfile, parsed.gitremote, parsed.gitremoteuri, parsed.gitbranch)
        else:
            print("Could not decrypt GPG key based on the entered passphrase; continuing without decrypting secrets")
    elif parsed.action == "testgpgpass":
        if testgpgpass(parsed.gpgpass, parsed.gpgseckeyid):
            print("Correct passphrase")
        else:
            print("Incorrect passphrase")
    else:
        raise Exception(f"No handler for action '{parsed.action}'")


# Unless we are running this script directly on the commandline, the main()
# function will NOT execute
if __name__ == '__main__':
    sys.exit(main(*sys.argv))

AWSTemplateFormatVersion: 2010-09-09
Description: me.micahrl.com and com.micahrl.me static sites on S3 + CloudFront

Parameters:
  AthenaDatabaseName:
    Type: String
    Default: micahrl_web_prod_logs
    Description: Athena/Glue database name (lowercase only)
    AllowedPattern: ^[a-z0-9_]+$
    ConstraintDescription: Must contain only lowercase letters, numbers, and underscores

  LogsBucketName:
    Type: String
    Default: micahrl-web-prod-logs
    Description: S3 bucket name for CloudFront access logs

  ObverseDomain:
    Type: String
    Default: me.micahrl.com
    Description: Obverse domain name for the static site

  ObverseBucketName:
    Type: String
    Default: micahrl-web-prod-obverse
    Description: S3 bucket name for obverse content

  ObverseHostedZoneId:
    Type: String
    Description: Route53 hosted zone ID for obverse domain

  ReverseDomain:
    Type: String
    Default: com.micahrl.me
    Description: Reverse domain name for the static site

  ReverseBucketName:
    Type: String
    Default: micahrl-web-prod-reverse
    Description: S3 bucket name for reverse content

  ReverseHostedZoneId:
    Type: String
    Description: Route53 hosted zone ID for reverse domain

Resources:
  LogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref LogsBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            ExpirationInDays: 365
            Prefix: cloudfront/
          - Id: DeleteOldAthenaResults
            Status: Enabled
            ExpirationInDays: 30
            Prefix: athena-results/
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred

  # ===== OBVERSE DOMAIN =====

  ObverseKeyValueStore:
    Type: AWS::CloudFront::KeyValueStore
    Properties:
      Name: !Sub "${AWS::StackName}-obverse-redirects"
      Comment: Redirect mappings for obverse domain

  ObverseHeadersKeyValueStore:
    Type: AWS::CloudFront::KeyValueStore
    Properties:
      Name: !Sub "${AWS::StackName}-obverse-headers"
      Comment: Custom response headers for obverse domain

  ObverseIndexRewriteFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub "${AWS::StackName}-obverse-index-rewrite"
      AutoPublish: true
      FunctionCode: !Sub |
        import cf from 'cloudfront';

        const kvsId = '${ObverseKeyValueStore}';

        async function handler(event) {
          const request = event.request;
          const uri = request.uri;

          // Try KVS lookup with recursion protection
          const kvs = cf.kvs(kvsId);
          let lookupUri = uri;
          const maxRedirects = 10;
          let redirectCount = 0;

          while (redirectCount < maxRedirects) {
            try {
              const value = await kvs.get(lookupUri);
              if (value) {
                lookupUri = value;
                redirectCount++;
              } else {
                break;
              }
            } catch (err) {
              // Key not found or other error, break out
              break;
            }
          }

          // If we found a different path through KVS, use it
          if (lookupUri !== uri) {
            request.uri = lookupUri;
          }
          // Otherwise fall back to index.html normalization for trailing slashes
          else if (uri.endsWith('/')) {
            request.uri += 'index.html';
          }

          return request;
        }
      FunctionConfig:
        Comment: KVS redirects with fallback to index.html rewriting
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !GetAtt ObverseKeyValueStore.Arn

  ObverseHeaderResponseFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub "${AWS::StackName}-obverse-header-response"
      AutoPublish: true
      FunctionCode: !Sub |
        import cf from 'cloudfront';

        const kvsId = '${ObverseHeadersKeyValueStore}';

        async function handler(event) {
          const response = event.response;
          const request = event.request;
          const path = request.uri;

          // Build hierarchical path list: /, /one/, /one/two/, /one/two/three.txt
          const parts = path.split('/').filter(p => p);
          const paths = ['/'];

          // Add each parent directory with trailing slash
          for (let i = 0; i < parts.length - 1; i++) {
            paths.push('/' + parts.slice(0, i + 1).join('/') + '/');
          }

          // Add the full path as-is (unless it's just /)
          if (path !== '/') {
            paths.push(path);
          }

          // Collect headers from all paths in order (parent to child)
          const kvs = cf.kvs(kvsId);
          const headers = {};

          for (const lookupPath of paths) {
            try {
              const value = await kvs.get(lookupPath);
              if (value) {
                // Parse line-delimited headers: "Header-Name: value"
                const lines = value.split('\n');
                for (const line of lines) {
                  const trimmed = line.trim();
                  if (trimmed && trimmed.includes(':')) {
                    const colonIndex = trimmed.indexOf(':');
                    const headerName = trimmed.substring(0, colonIndex).trim().toLowerCase();
                    const headerValue = trimmed.substring(colonIndex + 1).trim();
                    if (headerName) {
                      headers[headerName] = { value: headerValue };
                    }
                  }
                }
              }
            } catch (err) {
              // Key not found, continue
            }
          }

          // Handle special pattern for path-based headers with $1 substitution
          try {
            const patternValue = await kvs.get('**/*');
            if (patternValue) {
              const lines = patternValue.split('\n');
              for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && trimmed.includes(':')) {
                  const colonIndex = trimmed.indexOf(':');
                  const headerName = trimmed.substring(0, colonIndex).trim().toLowerCase();
                  let headerValue = trimmed.substring(colonIndex + 1).trim();
                  // Replace $1 with the request path
                  headerValue = headerValue.replace('$1', path);
                  if (headerName) {
                    headers[headerName] = { value: headerValue };
                  }
                }
              }
            }
          } catch (err) {
            // Pattern not found, continue
          }

          // Apply headers to response
          response.headers = response.headers || {};
          for (const [name, header] of Object.entries(headers)) {
            response.headers[name] = header;
          }

          return response;
        }
      FunctionConfig:
        Comment: Hierarchical custom headers from KVS
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !GetAtt ObverseHeadersKeyValueStore.Arn

  ObverseContentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref ObverseBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  ObverseContentBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ObverseContentBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontServicePrincipalReadOnly
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub "${ObverseContentBucket.Arn}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${ObverseCloudFrontDistribution}"

  ObverseCloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "${ObverseDomain}-oac"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  ObverseCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref ObverseDomain
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref ObverseDomain
          HostedZoneId: !Ref ObverseHostedZoneId

  ObverseCloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        HttpVersion: http2and3
        Comment: !Sub "CloudFront distribution for ${ObverseDomain}"

        Aliases:
          - !Ref ObverseDomain
        ViewerCertificate:
          AcmCertificateArn: !Ref ObverseCertificate
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021

        Origins:
          - Id: S3Origin
            DomainName: !GetAtt ObverseContentBucket.RegionalDomainName
            OriginAccessControlId: !Ref ObverseCloudFrontOriginAccessControl
            S3OriginConfig: {}

        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
          CachedMethods:
            - GET
            - HEAD
          Compress: true
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # CachingOptimized managed policy
          FunctionAssociations:
            - EventType: viewer-request
              FunctionARN: !GetAtt ObverseIndexRewriteFunction.FunctionMetadata.FunctionARN
            - EventType: viewer-response
              FunctionARN: !GetAtt ObverseHeaderResponseFunction.FunctionMetadata.FunctionARN

        DefaultRootObject: index.html

        # S3 with OAC returns 403 for missing objects, map to 404 page
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 404
            ResponsePagePath: /404.html
            ErrorCachingMinTTL: 300

        Logging:
          Bucket: !GetAtt LogsBucket.DomainName
          Prefix: !Sub "cloudfront/${ObverseDomain}/"
          IncludeCookies: false

        PriceClass: PriceClass_100

  ObverseDNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref ObverseHostedZoneId
      Name: !Ref ObverseDomain
      Type: A
      # Alias records inherit TTL from target (CloudFront uses 60s), cannot set TTL explicitly
      AliasTarget:
        DNSName: !GetAtt ObverseCloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2  # CloudFront hosted zone ID (always this value)
        EvaluateTargetHealth: false

  # ===== REVERSE DOMAIN =====

  ReverseKeyValueStore:
    Type: AWS::CloudFront::KeyValueStore
    Properties:
      Name: !Sub "${AWS::StackName}-reverse-redirects"
      Comment: Redirect mappings for reverse domain

  ReverseHeadersKeyValueStore:
    Type: AWS::CloudFront::KeyValueStore
    Properties:
      Name: !Sub "${AWS::StackName}-reverse-headers"
      Comment: Custom response headers for reverse domain

  ReverseIndexRewriteFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub "${AWS::StackName}-reverse-index-rewrite"
      AutoPublish: true
      FunctionCode: !Sub |
        import cf from 'cloudfront';

        const kvsId = '${ReverseKeyValueStore}';

        async function handler(event) {
          const request = event.request;
          const uri = request.uri;

          // Try KVS lookup with recursion protection
          const kvs = cf.kvs(kvsId);
          let lookupUri = uri;
          const maxRedirects = 10;
          let redirectCount = 0;

          while (redirectCount < maxRedirects) {
            try {
              const value = await kvs.get(lookupUri);
              if (value) {
                lookupUri = value;
                redirectCount++;
              } else {
                break;
              }
            } catch (err) {
              // Key not found or other error, break out
              break;
            }
          }

          // If we found a different path through KVS, use it
          if (lookupUri !== uri) {
            request.uri = lookupUri;
          }
          // Otherwise fall back to index.html normalization for trailing slashes
          else if (uri.endsWith('/')) {
            request.uri += 'index.html';
          }

          return request;
        }
      FunctionConfig:
        Comment: KVS redirects with fallback to index.html rewriting
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !GetAtt ReverseKeyValueStore.Arn

  ReverseHeaderResponseFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub "${AWS::StackName}-reverse-header-response"
      AutoPublish: true
      FunctionCode: !Sub |
        import cf from 'cloudfront';

        const kvsId = '${ReverseHeadersKeyValueStore}';

        async function handler(event) {
          const response = event.response;
          const request = event.request;
          const path = request.uri;

          // Build hierarchical path list: /, /one/, /one/two/, /one/two/three.txt
          const parts = path.split('/').filter(p => p);
          const paths = ['/'];

          // Add each parent directory with trailing slash
          for (let i = 0; i < parts.length - 1; i++) {
            paths.push('/' + parts.slice(0, i + 1).join('/') + '/');
          }

          // Add the full path as-is (unless it's just /)
          if (path !== '/') {
            paths.push(path);
          }

          // Collect headers from all paths in order (parent to child)
          const kvs = cf.kvs(kvsId);
          const headers = {};

          for (const lookupPath of paths) {
            try {
              const value = await kvs.get(lookupPath);
              if (value) {
                // Parse line-delimited headers: "Header-Name: value"
                const lines = value.split('\n');
                for (const line of lines) {
                  const trimmed = line.trim();
                  if (trimmed && trimmed.includes(':')) {
                    const colonIndex = trimmed.indexOf(':');
                    const headerName = trimmed.substring(0, colonIndex).trim().toLowerCase();
                    const headerValue = trimmed.substring(colonIndex + 1).trim();
                    if (headerName) {
                      headers[headerName] = { value: headerValue };
                    }
                  }
                }
              }
            } catch (err) {
              // Key not found, continue
            }
          }

          // Handle special pattern for path-based headers with $1 substitution
          try {
            const patternValue = await kvs.get('**/*');
            if (patternValue) {
              const lines = patternValue.split('\n');
              for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed && trimmed.includes(':')) {
                  const colonIndex = trimmed.indexOf(':');
                  const headerName = trimmed.substring(0, colonIndex).trim().toLowerCase();
                  let headerValue = trimmed.substring(colonIndex + 1).trim();
                  // Replace $1 with the request path
                  headerValue = headerValue.replace('$1', path);
                  if (headerName) {
                    headers[headerName] = { value: headerValue };
                  }
                }
              }
            }
          } catch (err) {
            // Pattern not found, continue
          }

          // Apply headers to response
          response.headers = response.headers || {};
          for (const [name, header] of Object.entries(headers)) {
            response.headers[name] = header;
          }

          return response;
        }
      FunctionConfig:
        Comment: Hierarchical custom headers from KVS
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !GetAtt ReverseHeadersKeyValueStore.Arn

  ReverseContentBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref ReverseBucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  ReverseContentBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ReverseContentBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontServicePrincipalReadOnly
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub "${ReverseContentBucket.Arn}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${ReverseCloudFrontDistribution}"

  ReverseCloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "${ReverseDomain}-oac"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  ReverseCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref ReverseDomain
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref ReverseDomain
          HostedZoneId: !Ref ReverseHostedZoneId

  ReverseCloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        HttpVersion: http2and3
        Comment: !Sub "CloudFront distribution for ${ReverseDomain}"

        Aliases:
          - !Ref ReverseDomain
        ViewerCertificate:
          AcmCertificateArn: !Ref ReverseCertificate
          SslSupportMethod: sni-only
          MinimumProtocolVersion: TLSv1.2_2021

        Origins:
          - Id: S3Origin
            DomainName: !GetAtt ReverseContentBucket.RegionalDomainName
            OriginAccessControlId: !Ref ReverseCloudFrontOriginAccessControl
            S3OriginConfig: {}

        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
          CachedMethods:
            - GET
            - HEAD
          Compress: true
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # CachingOptimized managed policy
          FunctionAssociations:
            - EventType: viewer-request
              FunctionARN: !GetAtt ReverseIndexRewriteFunction.FunctionMetadata.FunctionARN
            - EventType: viewer-response
              FunctionARN: !GetAtt ReverseHeaderResponseFunction.FunctionMetadata.FunctionARN

        DefaultRootObject: index.html

        # S3 with OAC returns 403 for missing objects, map to 404 page
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 404
            ResponsePagePath: /404.html
            ErrorCachingMinTTL: 300

        Logging:
          Bucket: !GetAtt LogsBucket.DomainName
          Prefix: !Sub "cloudfront/${ReverseDomain}/"
          IncludeCookies: false

        PriceClass: PriceClass_100

  ReverseDNSRecord:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref ReverseHostedZoneId
      Name: !Ref ReverseDomain
      Type: A
      # Alias records inherit TTL from target (CloudFront uses 60s), cannot set TTL explicitly
      AliasTarget:
        DNSName: !GetAtt ReverseCloudFrontDistribution.DomainName
        HostedZoneId: Z2FDTNDATAQYW2  # CloudFront hosted zone ID (always this value)
        EvaluateTargetHealth: false

  DeployerGroup:
    Type: AWS::IAM::Group
    Properties:
      GroupName: !Sub "${AWS::StackName}-Deployers"
      Policies:
        - PolicyName: DeployToS3AndInvalidateCloudFront
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowS3BucketListing
                Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !GetAtt ObverseContentBucket.Arn
                  - !GetAtt ReverseContentBucket.Arn
              - Sid: AllowS3ObjectOperations
                Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:DeleteObject
                Resource:
                  - !Sub "${ObverseContentBucket.Arn}/*"
                  - !Sub "${ReverseContentBucket.Arn}/*"
              - Sid: AllowCloudFrontInvalidation
                Effect: Allow
                Action:
                  - cloudfront:CreateInvalidation
                  - cloudfront:GetInvalidation
                Resource:
                  - !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${ObverseCloudFrontDistribution}"
                  - !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${ReverseCloudFrontDistribution}"
              - Sid: AllowKeyValueStoreManagement
                Effect: Allow
                Action:
                  - cloudfront-keyvaluestore:DescribeKeyValueStore
                  - cloudfront-keyvaluestore:UpdateKeys
                  - cloudfront-keyvaluestore:ListKeys
                Resource:
                  - !GetAtt ObverseKeyValueStore.Arn
                  - !GetAtt ReverseKeyValueStore.Arn
                  - !GetAtt ObverseHeadersKeyValueStore.Arn
                  - !GetAtt ReverseHeadersKeyValueStore.Arn
              - Sid: AllowKeyValueStoreCreation
                Effect: Allow
                Action:
                  - cloudfront:CreateKeyValueStore
                  - cloudfront:DeleteKeyValueStore
                  - cloudfront:ListKeyValueStores
                Resource: "*"
              - Sid: AllowFunctionRead
                Effect: Allow
                Action:
                  - cloudfront:DescribeFunction
                  - cloudfront:GetFunction
                Resource:
                  - !GetAtt ObverseIndexRewriteFunction.FunctionMetadata.FunctionARN
                  - !GetAtt ReverseIndexRewriteFunction.FunctionMetadata.FunctionARN
                  - !GetAtt ObverseHeaderResponseFunction.FunctionMetadata.FunctionARN
                  - !GetAtt ReverseHeaderResponseFunction.FunctionMetadata.FunctionARN

  # ===== ATHENA LOG ANALYSIS =====

  AthenaWorkGroup:
    Type: AWS::Athena::WorkGroup
    Properties:
      Name: !Sub "${AWS::StackName}-logs"
      WorkGroupConfiguration:
        ResultConfiguration:
          OutputLocation: !Sub "s3://${LogsBucket}/athena-results/"
        EnforceWorkGroupConfiguration: true
        PublishCloudWatchMetricsEnabled: false

  AthenaDatabase:
    Type: AWS::Glue::Database
    Properties:
      CatalogId: !Ref AWS::AccountId
      DatabaseInput:
        Name: !Ref AthenaDatabaseName
        Description: CloudFront access logs database

  AthenaLogsTable:
    Type: AWS::Glue::Table
    Properties:
      CatalogId: !Ref AWS::AccountId
      DatabaseName: !Ref AthenaDatabase
      TableInput:
        Name: cloudfront_access_logs
        TableType: EXTERNAL_TABLE
        Parameters:
          EXTERNAL: "TRUE"
          skip.header.line.count: "2"
        StorageDescriptor:
          Columns:
            - Name: log_date
              Type: string
            - Name: log_time
              Type: string
            - Name: edge_location
              Type: string
            - Name: bytes_sent
              Type: bigint
            - Name: client_ip
              Type: string
            - Name: http_method
              Type: string
            - Name: host
              Type: string
            - Name: uri_stem
              Type: string
            - Name: status_code
              Type: int
            - Name: referer
              Type: string
            - Name: user_agent
              Type: string
            - Name: query_string
              Type: string
            - Name: cookie
              Type: string
            - Name: edge_result_type
              Type: string
            - Name: edge_request_id
              Type: string
            - Name: host_header
              Type: string
            - Name: protocol
              Type: string
            - Name: bytes_received
              Type: bigint
            - Name: time_taken
              Type: float
            - Name: forwarded_for
              Type: string
            - Name: ssl_protocol
              Type: string
            - Name: ssl_cipher
              Type: string
            - Name: edge_response_result_type
              Type: string
            - Name: protocol_version
              Type: string
            - Name: fle_status
              Type: string
            - Name: fle_encrypted_fields
              Type: int
            - Name: port
              Type: int
            - Name: time_to_first_byte
              Type: float
            - Name: edge_detailed_result_type
              Type: string
            - Name: content_type
              Type: string
            - Name: content_length
              Type: bigint
            - Name: range_start
              Type: bigint
            - Name: range_end
              Type: bigint
          Location: !Sub "s3://${LogsBucket}/cloudfront/"
          InputFormat: org.apache.hadoop.mapred.TextInputFormat
          OutputFormat: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat
          SerdeInfo:
            SerializationLibrary: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
            Parameters:
              field.delim: "\t"
              serialization.format: "\t"

Outputs:
  LogsBucketName:
    Description: Name of the S3 bucket for access logs (shared)
    Value: !Ref LogsBucket

  ObverseContentBucketName:
    Value: !Ref ObverseContentBucket

  ObverseKeyValueStoreId:
    Description: KeyValueStore ID for managing redirects
    Value: !Ref ObverseKeyValueStore

  ObverseKeyValueStoreArn:
    Value: !GetAtt ObverseKeyValueStore.Arn

  ObverseHeadersKeyValueStoreId:
    Description: KeyValueStore ID for managing custom headers
    Value: !Ref ObverseHeadersKeyValueStore

  ObverseHeadersKeyValueStoreArn:
    Value: !GetAtt ObverseHeadersKeyValueStore.Arn

  ObverseCloudFrontDistributionId:
    Description: For invalidations
    Value: !Ref ObverseCloudFrontDistribution

  ObverseCloudFrontDomainName:
    Value: !GetAtt ObverseCloudFrontDistribution.DomainName

  ObverseWebsiteURL:
    Value: !Sub "https://${ObverseDomain}"

  ReverseContentBucketName:
    Value: !Ref ReverseContentBucket

  ReverseKeyValueStoreId:
    Description: KeyValueStore ID for managing redirects
    Value: !Ref ReverseKeyValueStore

  ReverseKeyValueStoreArn:
    Value: !GetAtt ReverseKeyValueStore.Arn

  ReverseHeadersKeyValueStoreId:
    Description: KeyValueStore ID for managing custom headers
    Value: !Ref ReverseHeadersKeyValueStore

  ReverseHeadersKeyValueStoreArn:
    Value: !GetAtt ReverseHeadersKeyValueStore.Arn

  ReverseCloudFrontDistributionId:
    Description: For invalidations
    Value: !Ref ReverseCloudFrontDistribution

  ReverseCloudFrontDomainName:
    Value: !GetAtt ReverseCloudFrontDistribution.DomainName

  ReverseWebsiteURL:
    Value: !Sub "https://${ReverseDomain}"

  DeployerGroupName:
    Description: IAM group for deployment access
    Value: !Ref DeployerGroup

  DeployerGroupArn:
    Value: !GetAtt DeployerGroup.Arn

  AthenaWorkGroupName:
    Description: Athena workgroup for querying logs
    Value: !Ref AthenaWorkGroup

  AthenaDatabaseName:
    Description: Athena database name
    Value: !Ref AthenaDatabase

  AthenaQueryExamples:
    Description: Example Athena queries for log analysis
    Value: !Sub |
      # Query in AWS Console: Athena → Query Editor → Select workgroup: ${AthenaWorkGroup}

      # Top 10 pages by requests (with actual domain)
      SELECT host_header, uri_stem, COUNT(*) as requests
      FROM ${AthenaDatabase}.cloudfront_access_logs
      GROUP BY host_header, uri_stem
      ORDER BY requests DESC
      LIMIT 10;

      # Top 10 paths across all domains
      SELECT uri_stem, COUNT(*) as requests
      FROM ${AthenaDatabase}.cloudfront_access_logs
      GROUP BY uri_stem
      ORDER BY requests DESC
      LIMIT 10;

      # 404 errors
      SELECT host_header, uri_stem, COUNT(*) as count
      FROM ${AthenaDatabase}.cloudfront_access_logs
      WHERE status_code = 404
      GROUP BY host_header, uri_stem
      ORDER BY count DESC;

      # Traffic by status code
      SELECT status_code, COUNT(*) as requests
      FROM ${AthenaDatabase}.cloudfront_access_logs
      GROUP BY status_code
      ORDER BY requests DESC;

  Deployment:
    Description: Commands to create a deployment user with access keys
    Value: !Sub |
      # Create a user, add to the deployer group, and create access keys (will only be displayed once)
      aws iam create-user --user-name github-micahrl-obverse-reverse-deployer
      aws iam add-user-to-group --user-name github-micahrl-obverse-reverse-deployer --group-name ${DeployerGroup}
      aws iam create-access-key --user-name github-micahrl-obverse-reverse-deployer
      # Use hugo to deploy the site
      hugo deploy --invalidateCDN ...

  KeyValueStoreManagement:
    Description: Commands for managing redirect KeyValueStores
    Value: !Sub |
      # List all KeyValueStores
      aws cloudfront list-key-value-stores

      # List all keys in the obverse KVS
      aws cloudfront-keyvaluestore list-keys --kvs-arn ${ObverseKeyValueStore.Arn}

      # Put a redirect mapping (e.g., /old-path -> /new-path)
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseKeyValueStore.Arn} \
        --puts '[{"Key":"/old-path","Value":"/new-path"}]'

      # Put multiple redirects at once
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseKeyValueStore.Arn} \
        --puts '[{"Key":"/old1","Value":"/new1"},{"Key":"/old2","Value":"/new2"}]'

      # Delete a redirect
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseKeyValueStore.Arn} \
        --deletes '[{"Key":"/old-path"}]'

      # Redirect chains are automatically followed (max 10 levels)
      # Example: /a -> /b, /b -> /c, request for /a will serve /c

      # Create a new KeyValueStore (for testing or migration)
      aws cloudfront create-key-value-store --name my-new-kvs --comment "My redirects"

      # Delete a KeyValueStore (must not be associated with any functions)
      aws cloudfront delete-key-value-store --if-match ETAG_FROM_DESCRIBE --name my-old-kvs

      # View function configuration to see current KVS association
      aws cloudfront get-function --name ${AWS::StackName}-obverse-index-rewrite

      # To change which KVS a function uses, update the CloudFormation template
      # and redeploy the stack - manual function updates would cause drift

      # Same commands work for reverse using: ${ReverseKeyValueStore.Arn} and ${AWS::StackName}-reverse-index-rewrite

  HeadersKeyValueStoreManagement:
    Description: Commands for managing custom response headers KeyValueStores
    Value: !Sub |
      # Headers are stored as line-delimited "Header-Name: value" strings
      # Headers are looked up hierarchically and merged (child overrides parent)

      # Example: Add headers to the root path
      # These will apply to all responses unless overridden
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn} \
        --puts '[{"Key":"/","Value":"X-Frame-Options: DENY\nX-Content-Type-Options: nosniff"}]'

      # Example: Override a header for a specific directory
      # For /blog/post.html, this will add both headers from / and the custom one from /blog/
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn} \
        --puts '[{"Key":"/blog/","Value":"Cache-Control: public, max-age=3600"}]'

      # Example: Add headers to a specific file
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn} \
        --puts '[{"Key":"/blog/post.html","Value":"X-Robots-Tag: noindex"}]'

      # Example: Special pattern for path-based headers with $1 substitution
      # This applies to ALL paths and $1 is replaced with the request path
      # Useful for Onion-Location headers pointing to Tor hidden services
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn} \
        --puts '[{"Key":"**/*","Value":"Onion-Location: http://example.onion$1"}]'

      # For path /one/two/three.txt, headers are looked up in this order:
      # 1. / (root)
      # 2. /one/ (first directory)
      # 3. /one/two/ (second directory)
      # 4. /one/two/three.txt (the file itself)
      # 5. **/* (special pattern with $1 = /one/two/three.txt)
      # Later definitions override earlier ones for the same header name
      # Different headers from parents are combined

      # List all header mappings
      aws cloudfront-keyvaluestore list-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn}

      # Delete a header mapping
      aws cloudfront-keyvaluestore update-keys --kvs-arn ${ObverseHeadersKeyValueStore.Arn} \
        --deletes '[{"Key":"/blog/"}]'

      # Same commands work for reverse using: ${ReverseHeadersKeyValueStore.Arn}
